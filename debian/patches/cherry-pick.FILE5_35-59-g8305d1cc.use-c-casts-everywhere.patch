Subject: Use c++ casts everywhere
Origin: FILE5_35-59-g8305d1cc <https://github.com/file/file/commit/FILE5_35-59-g8305d1cc>
Upstream-Author: Christos Zoulas <christos@zoulas.com>
Date: Wed Feb 20 02:35:27 2019 +0000

--- a/src/apprentice.c
+++ b/src/apprentice.c
@@ -52,10 +52,10 @@
 #include <limits.h>
 
 
-#define	EATAB {while (isascii((unsigned char) *l) && \
-		      isspace((unsigned char) *l))  ++l;}
-#define LOWCASE(l) (isupper((unsigned char) (l)) ? \
-			tolower((unsigned char) (l)) : (l))
+#define	EATAB {while (isascii(CAST(unsigned char, *l)) && \
+		      isspace(CAST(unsigned char, *l)))  ++l;}
+#define LOWCASE(l) (isupper(CAST(unsigned char, l)) ? \
+			tolower(CAST(unsigned char, l)) : (l))
 /*
  * Work around a bug in headers on Digital Unix.
  * At least confirmed for: OSF1 V4.0 878
@@ -74,8 +74,8 @@
 #define MAP_FILE 0
 #endif
 
-#define ALLOC_CHUNK	(size_t)10
-#define ALLOC_INCR	(size_t)200
+#define ALLOC_CHUNK	CAST(size_t, 10)
+#define ALLOC_INCR	CAST(size_t, 200)
 
 #define MAP_TYPE_USER	0
 #define MAP_TYPE_MALLOC	1
@@ -305,7 +305,7 @@
 {
 	int type;
 
-	if (isalpha((unsigned char)l[1])) {
+	if (isalpha(CAST(unsigned char, l[1]))) {
 		switch (l[1]) {
 		case 'C':
 			/* "dC" and "uC" */
@@ -340,7 +340,7 @@
 			return FILE_INVALID;
 		}
 		l += 2;
-	} else if (isdigit((unsigned char)l[1])) {
+	} else if (isdigit(CAST(unsigned char, l[1]))) {
 		/*
 		 * "d{num}" and "u{num}"; we only support {num} values
 		 * of 1, 2, 4, and 8 - the Single UNIX Specification
@@ -351,7 +351,7 @@
 		 * neither of them support values bigger than 8 or
 		 * non-power-of-2 values.
 		 */
-		if (isdigit((unsigned char)l[2])) {
+		if (isdigit(CAST(unsigned char, l[2]))) {
 			/* Multi-digit, so > 9 */
 			return FILE_INVALID;
 		}
@@ -437,8 +437,8 @@
 
 	if (magicsize != FILE_MAGICSIZE) {
 		file_error(ms, 0, "magic element size %lu != %lu",
-		    (unsigned long)sizeof(*map->magic[0]),
-		    (unsigned long)FILE_MAGICSIZE);
+		    CAST(unsigned long, sizeof(*map->magic[0])),
+		    CAST(unsigned long, FILE_MAGICSIZE));
 		return -1;
 	}
 
@@ -451,7 +451,7 @@
 
 #ifndef COMPILE_ONLY
 	map = apprentice_map(ms, fn);
-	if (map == (struct magic_map *)-1)
+	if (map == RCAST(struct magic_map *, -1))
 		return -1;
 	if (map == NULL) {
 		if (ms->flags & MAGIC_CHECK)
@@ -503,7 +503,7 @@
 	struct magic_set *ms;
 	size_t i, len;
 
-	if ((ms = CAST(struct magic_set *, calloc((size_t)1,
+	if ((ms = CAST(struct magic_set *, calloc(CAST(size_t, 1u),
 	    sizeof(struct magic_set)))) == NULL)
 		return NULL;
 
@@ -831,7 +831,7 @@
 	case FILE_LEDOUBLE:
 		return 8;
 	default:
-		return (size_t)~0;
+		return CAST(size_t, ~0);
 	}
 }
 
@@ -886,7 +886,7 @@
 	case FILE_BEDOUBLE:
 	case FILE_LEDOUBLE:
 		ts = typesize(m->type);
-		if (ts == (size_t)~0)
+		if (ts == CAST(size_t, ~0))
 			abort();
 		val += ts * MULT;
 		break;
@@ -1101,7 +1101,7 @@
 			break;
 
 		/* binary test if pattern is not text */
-		if (file_looks_utf8(m->value.us, (size_t)m->vallen, NULL,
+		if (file_looks_utf8(m->value.us, CAST(size_t, m->vallen), NULL,
 		    NULL) <= 0)
 			mstart->flag |= BINTEST;
 		else
@@ -1182,7 +1182,7 @@
 				size_t i;
 
 				for (i = 0; bang[i].name != NULL; i++) {
-					if ((size_t)(len - 2) > bang[i].len &&
+					if (CAST(size_t, len - 2) > bang[i].len &&
 					    memcmp(bang[i].name, line + 2,
 					    bang[i].len) == 0)
 						break;
@@ -1235,7 +1235,7 @@
 private int
 cmpstrp(const void *p1, const void *p2)
 {
-        return strcmp(*(char *const *)p1, *(char *const *)p2);
+        return strcmp(*RCAST(char *const *, p1), *RCAST(char *const *, p2));
 }
 
 
@@ -1261,10 +1261,10 @@
 		if (me[i].mp->flag & BINTEST) {
 			char *p = strstr(me[i].mp->desc, text);
 			if (p && (p == me[i].mp->desc ||
-			    isspace((unsigned char)p[-1])) &&
+			    isspace(CAST(unsigned char, p[-1]))) &&
 			    (p + len - me[i].mp->desc == MAXstring
 			    || (p[len] == '\0' ||
-			    isspace((unsigned char)p[len]))))
+			    isspace(CAST(unsigned char, p[len])))))
 				(void)fprintf(stderr, "*** Possible "
 				    "binary test for text type\n");
 		}
@@ -1460,12 +1460,12 @@
 		 * the sign extension must have happened.
 		 */
 		case FILE_BYTE:
-			v = (signed char) v;
+			v = CAST(signed char,  v);
 			break;
 		case FILE_SHORT:
 		case FILE_BESHORT:
 		case FILE_LESHORT:
-			v = (short) v;
+			v = CAST(short, v);
 			break;
 		case FILE_DATE:
 		case FILE_BEDATE:
@@ -1482,7 +1482,7 @@
 		case FILE_FLOAT:
 		case FILE_BEFLOAT:
 		case FILE_LEFLOAT:
-			v = (int32_t) v;
+			v = CAST(int32_t, v);
 			break;
 		case FILE_QUAD:
 		case FILE_BEQUAD:
@@ -1499,7 +1499,7 @@
 		case FILE_DOUBLE:
 		case FILE_BEDOUBLE:
 		case FILE_LEDOUBLE:
-			v = (int64_t) v;
+			v = CAST(int64_t, v);
 			break;
 		case FILE_STRING:
 		case FILE_PSTRING:
@@ -1626,7 +1626,7 @@
 
 	for (p = cond_tbl; p->len; p++) {
 		if (strncmp(l, p->name, p->len) == 0 &&
-		    isspace((unsigned char)l[p->len])) {
+		    isspace(CAST(unsigned char, l[p->len]))) {
 			if (t)
 				*t = l + p->len;
 			break;
@@ -1684,7 +1684,7 @@
 {
 	const char *l = *lp;
 
-	while (!isspace((unsigned char)*++l))
+	while (!isspace(CAST(unsigned char, *++l)))
 		switch (*l) {
 		case CHAR_INDIRECT_RELATIVE:
 			m->str_flags |= INDIRECT_RELATIVE;
@@ -1710,7 +1710,7 @@
 
 	++l;
 	m->mask_op |= op;
-	val = (uint64_t)strtoull(l, &t, 0);
+	val = CAST(uint64_t, strtoull(l, &t, 0));
 	l = t;
 	m->num_mask = file_signextend(ms, m, val);
 	eatsize(&l);
@@ -1724,7 +1724,7 @@
 	char *t;
 	int have_range = 0;
 
-	while (!isspace((unsigned char)*++l)) {
+	while (!isspace(CAST(unsigned char, *++l))) {
 		switch (*l) {
 		case '0':  case '1':  case '2':
 		case '3':  case '4':  case '5':
@@ -1806,7 +1806,7 @@
 			goto out;
 		}
 		/* allow multiple '/' for readability */
-		if (l[1] == '/' && !isspace((unsigned char)l[2]))
+		if (l[1] == '/' && !isspace(CAST(unsigned char, l[2])))
 			l++;
 	}
 	if (string_modifier_check(ms, m) == -1)
@@ -1861,7 +1861,7 @@
 			return -1;
 		}
 		m = &me->mp[me->cont_count - 1];
-		diff = (int32_t)cont_level - (int32_t)m->cont_level;
+		diff = CAST(int32_t, cont_level) - CAST(int32_t, m->cont_level);
 		if (diff > 1)
 			file_magwarn(ms, "New continuation level %u is more "
 			    "than one larger than current level %u", cont_level,
@@ -1920,7 +1920,7 @@
 	}
 
 	/* get offset, then skip over it */
-	m->offset = (int32_t)strtol(l, &t, 0);
+	m->offset = CAST(int32_t, strtol(l, &t, 0));
         if (l == t) {
 		if (ms->flags & MAGIC_CHECK)
 			file_magwarn(ms, "offset `%s' invalid", l);
@@ -2018,8 +2018,8 @@
 			m->in_op |= FILE_OPINDIRECT;
 			l++;
 		}
-		if (isdigit((unsigned char)*l) || *l == '-') {
-			m->in_offset = (int32_t)strtol(l, &t, 0);
+		if (isdigit(CAST(unsigned char, *l)) || *l == '-') {
+			m->in_offset = CAST(int32_t, strtol(l, &t, 0));
 			if (l == t) {
 				if (ms->flags & MAGIC_CHECK)
 					file_magwarn(ms,
@@ -2082,7 +2082,8 @@
 			 */
 			if (*l == 'd')
 				m->type = get_standard_integer_type(l, &l);
-			else if (*l == 's' && !isalpha((unsigned char)l[1])) {
+			else if (*l == 's'
+			    && !isalpha(CAST(unsigned char, l[1]))) {
 				m->type = FILE_STRING;
 				++l;
 			}
@@ -2172,8 +2173,8 @@
 		break;
 	default:
   		m->reln = '=';	/* the default relation */
-		if (*l == 'x' && ((isascii((unsigned char)l[1]) &&
-		    isspace((unsigned char)l[1])) || !l[1])) {
+		if (*l == 'x' && ((isascii(CAST(unsigned char, l[1])) &&
+		    isspace(CAST(unsigned char, l[1]))) || !l[1])) {
 			m->reln = *l;
 			++l;
 		}
@@ -2270,11 +2271,11 @@
 		file_magwarn(ms, "Too large factor `%lu'", factor);
 		goto out;
 	}
-	if (*el && !isspace((unsigned char)*el)) {
+	if (*el && !isspace(CAST(unsigned char, *el))) {
 		file_magwarn(ms, "Bad factor `%s'", l);
 		goto out;
 	}
-	m->factor = (uint8_t)factor;
+	m->factor = CAST(uint8_t, factor);
 	if (m->factor == 0 && m->factor_op == FILE_FACTOR_OP_DIV) {
 		file_magwarn(ms, "Cannot have factor op `%c' and factor %u",
 		    m->factor_op, m->factor);
@@ -2305,7 +2306,7 @@
 	if (buf[0] != '\0') {
 		len = nt ? strlen(buf) : len;
 		file_magwarn(ms, "Current entry already has a %s type "
-		    "`%.*s', new type `%s'", name, (int)len, buf, l);
+		    "`%.*s', new type `%s'", name, CAST(int, len), buf, l);
 		return -1;
 	}
 
@@ -2326,7 +2327,7 @@
 			file_magwarn(ms, "%s type `%s' truncated %"
 			    SIZE_T_FORMAT "u", name, line, i);
 	} else {
-		if (!isspace((unsigned char)*l) && !goodchar(*l, extra))
+		if (!isspace(CAST(unsigned char, *l)) && !goodchar(*l, extra))
 			file_magwarn(ms, "%s type `%s' has bad char '%c'",
 			    name, line, *l);
 		if (nt)
@@ -2428,7 +2429,7 @@
 		if (*ptr == '#')
 			ptr++;
 #define CHECKLEN() do { \
-	for (len = cnt = 0; isdigit((unsigned char)*ptr); ptr++, cnt++) \
+	for (len = cnt = 0; isdigit(CAST(unsigned char, *ptr)); ptr++, cnt++) \
 		len = len * 10 + (*ptr - '0'); \
 	if (cnt > 5 || len > 1024) \
 		goto toolong; \
@@ -2546,11 +2547,11 @@
 	case FILE_FMT_STR:
 		if (*ptr == '-')
 			ptr++;
-		while (isdigit((unsigned char )*ptr))
+		while (isdigit(CAST(unsigned char, *ptr)))
 			ptr++;
 		if (*ptr == '.') {
 			ptr++;
-			while (isdigit((unsigned char )*ptr))
+			while (isdigit(CAST(unsigned char , *ptr)))
 				ptr++;
 		}
 
@@ -2695,7 +2696,7 @@
 		return 0;
 	default:
 		errno = 0;
-		ull = (uint64_t)strtoull(*p, &ep, 0);
+		ull = CAST(uint64_t, strtoull(*p, &ep, 0));
 		m->value.q = file_signextend(ms, m, ull);
 		if (*p == ep) {
 			file_magwarn(ms, "Unparseable number `%s'", *p);
@@ -2704,24 +2705,24 @@
 			uint64_t x;
 			const char *q;
 
-			if (ts == (size_t)~0) {
+			if (ts == CAST(size_t, ~0)) {
 				file_magwarn(ms,
 				    "Expected numeric type got `%s'",
 				    type_tbl[m->type].name);
 			}
-			for (q = *p; isspace((unsigned char)*q); q++)
+			for (q = *p; isspace(CAST(unsigned char, *q)); q++)
 				continue;
 			if (*q == '-')
-				ull = -(int64_t)ull;
+				ull = -CAST(int64_t, ull);
 			switch (ts) {
 			case 1:
-				x = (uint64_t)(ull & ~0xffULL);
+				x = CAST(uint64_t, ull & ~0xffULL);
 				break;
 			case 2:
-				x = (uint64_t)(ull & ~0xffffULL);
+				x = CAST(uint64_t, ull & ~0xffffULL);
 				break;
 			case 4:
-				x = (uint64_t)(ull & ~0xffffffffULL);
+				x = CAST(uint64_t, ull & ~0xffffffffULL);
 				break;
 			case 8:
 				x = 0;
@@ -2761,7 +2762,7 @@
 	int	val;
 
 	while ((c = *s++) != '\0') {
-		if (isspace((unsigned char) c))
+		if (isspace(CAST(unsigned char, c)))
 			break;
 		if (p >= pmax) {
 			file_error(ms, 0, "string too long: `%s'", origs);
@@ -2785,7 +2786,7 @@
 				/*FALLTHROUGH*/
 			default:
 				if (warn) {
-					if (isprint((unsigned char)c)) {
+					if (isprint(CAST(unsigned char, c))) {
 						/* Allow escaping of
 						 * ``relations'' */
 						if (strchr("<>&^=!", c) == NULL
@@ -2823,7 +2824,7 @@
 			case '!':
 			/* and baskslash itself */
 			case '\\':
-				*p++ = (char) c;
+				*p++ = CAST(char, c);
 				break;
 
 			case 'a':
@@ -2875,7 +2876,7 @@
 				}
 				else
 					--s;
-				*p++ = (char)val;
+				*p++ = CAST(char, val);
 				break;
 
 			/* \x and up to 2 hex digits */
@@ -2891,18 +2892,18 @@
 						--s;
 				} else
 					--s;
-				*p++ = (char)val;
+				*p++ = CAST(char, val);
 				break;
 			}
 		} else
-			*p++ = (char)c;
+			*p++ = CAST(char, c);
 	}
 	--s;
 out:
 	*p = '\0';
 	m->vallen = CAST(unsigned char, (p - origp));
 	if (m->type == FILE_PSTRING)
-		m->vallen += (unsigned char)file_pstring_length_size(m);
+		m->vallen += CAST(unsigned char, file_pstring_length_size(m));
 	return s;
 }
 
@@ -2911,9 +2912,9 @@
 private int
 hextoint(int c)
 {
-	if (!isascii((unsigned char) c))
+	if (!isascii(CAST(unsigned char, c)))
 		return -1;
-	if (isdigit((unsigned char) c))
+	if (isdigit(CAST(unsigned char, c)))
 		return c - '0';
 	if ((c >= 'a') && (c <= 'f'))
 		return c + 10 - 'a';
@@ -3068,11 +3069,11 @@
 		goto error;
 	}
 
-	map->len = (size_t)st.st_size;
+	map->len = CAST(size_t, st.st_size);
 #ifdef QUICK
 	map->type = MAP_TYPE_MMAP;
-	if ((map->p = mmap(0, (size_t)st.st_size, PROT_READ|PROT_WRITE,
-	    MAP_PRIVATE|MAP_FILE, fd, (off_t)0)) == MAP_FAILED) {
+	if ((map->p = mmap(0, CAST(size_t, st.st_size), PROT_READ|PROT_WRITE,
+	    MAP_PRIVATE|MAP_FILE, fd, CAST(off_t, 0))) == MAP_FAILED) {
 		file_error(ms, errno, "cannot map `%s'", dbname);
 		goto error;
 	}
@@ -3092,11 +3093,11 @@
 	fd = -1;
 
 	if (check_buffer(ms, map, dbname) != 0) {
-		rv = (struct magic_map *)-1;
+		rv = RCAST(struct magic_map *, -1);
 		goto error;
 	}
 #ifdef QUICK
-	if (mprotect(map->p, (size_t)st.st_size, PROT_READ) == -1) {
+	if (mprotect(map->p, CAST(size_t, st.st_size), PROT_READ) == -1) {
 		file_error(ms, errno, "cannot mprotect `%s'", dbname);
 		goto error;
 	}
@@ -3140,7 +3141,7 @@
 		    VERSIONNO, dbname, version);
 		return -1;
 	}
-	entries = (uint32_t)(map->len / sizeof(struct magic));
+	entries = CAST(uint32_t, map->len / sizeof(struct magic));
 	if ((entries * sizeof(struct magic)) != map->len) {
 		file_error(ms, 0, "Size of `%s' %" SIZE_T_FORMAT "u is not "
 		    "a multiple of %" SIZE_T_FORMAT "u",
@@ -3202,14 +3203,14 @@
 	hdr.h[1] = VERSIONNO;
 	memcpy(hdr.h + 2, map->nmagic, nm);
 
-	if (write(fd, &hdr, sizeof(hdr)) != (ssize_t)sizeof(hdr)) {
+	if (write(fd, &hdr, sizeof(hdr)) != CAST(ssize_t, sizeof(hdr))) {
 		file_error(ms, errno, "error writing `%s'", dbname);
 		goto out2;
 	}
 
 	for (i = 0; i < MAGIC_SETS; i++) {
 		len = m * map->nmagic[i];
-		if (write(fd, map->magic[i], len) != (ssize_t)len) {
+		if (write(fd, map->magic[i], len) != CAST(ssize_t, len)) {
 			file_error(ms, errno, "error writing `%s'", dbname);
 			goto out2;
 		}
@@ -3255,7 +3256,8 @@
 	q++;
 	/* Compatibility with old code that looked in .mime */
 	if (ms->flags & MAGIC_MIME) {
-		if (asprintf(&buf, "%.*s.mime%s", (int)(q - fn), fn, ext) < 0)
+		if (asprintf(&buf, "%.*s.mime%s", CAST(int, q - fn), fn, ext)
+		    < 0)
 			return NULL;
 		if (access(buf, R_OK) != -1) {
 			ms->flags &= MAGIC_MIME_TYPE;
@@ -3263,7 +3265,7 @@
 		}
 		free(buf);
 	}
-	if (asprintf(&buf, "%.*s%s", (int)(q - fn), fn, ext) < 0)
+	if (asprintf(&buf, "%.*s%s", CAST(int, q - fn), fn, ext) < 0)
 		return NULL;
 
 	/* Compatibility with old code that looked in .mime */
@@ -3290,8 +3292,8 @@
 swap2(uint16_t sv)
 {
 	uint16_t rv;
-	uint8_t *s = (uint8_t *)(void *)&sv;
-	uint8_t *d = (uint8_t *)(void *)&rv;
+	uint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));
+	uint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));
 	d[0] = s[1];
 	d[1] = s[0];
 	return rv;
@@ -3304,8 +3306,8 @@
 swap4(uint32_t sv)
 {
 	uint32_t rv;
-	uint8_t *s = (uint8_t *)(void *)&sv;
-	uint8_t *d = (uint8_t *)(void *)&rv;
+	uint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));
+	uint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));
 	d[0] = s[3];
 	d[1] = s[2];
 	d[2] = s[1];
@@ -3320,8 +3322,8 @@
 swap8(uint64_t sv)
 {
 	uint64_t rv;
-	uint8_t *s = (uint8_t *)(void *)&sv;
-	uint8_t *d = (uint8_t *)(void *)&rv;
+	uint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));
+	uint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));
 #if 0
 	d[0] = s[3];
 	d[1] = s[2];
@@ -3351,9 +3353,9 @@
 bs1(struct magic *m)
 {
 	m->cont_level = swap2(m->cont_level);
-	m->offset = swap4((uint32_t)m->offset);
-	m->in_offset = swap4((uint32_t)m->in_offset);
-	m->lineno = swap4((uint32_t)m->lineno);
+	m->offset = swap4(CAST(uint32_t, m->offset));
+	m->in_offset = swap4(CAST(uint32_t, m->in_offset));
+	m->lineno = swap4(CAST(uint32_t, m->lineno));
 	if (IS_STRING(m->type)) {
 		m->str_range = swap4(m->str_range);
 		m->str_flags = swap4(m->str_flags);
@@ -3385,7 +3387,7 @@
 file_pstring_get_length(const struct magic *m, const char *ss)
 {
 	size_t len = 0;
-	const unsigned char *s = (const unsigned char *)ss;
+	const unsigned char *s = RCAST(const unsigned char *, ss);
 	unsigned int s3, s2, s1, s0;
 
 	switch (m->str_flags & PSTRING_LEN) {
--- a/src/ascmagic.c
+++ b/src/ascmagic.c
@@ -127,7 +127,7 @@
 	int n_nel = 0;
 	int executable = 0;
 
-	size_t last_line_end = (size_t)-1;
+	size_t last_line_end = CAST(size_t, -1);
 	int has_long_lines = 0;
 
 	nbytes = trim_nuls(buf, nbytes);
@@ -151,7 +151,7 @@
 		    == NULL)
 			goto done;
 		buffer_init(&bb, b->fd, utf8_buf,
-		    (size_t)(utf8_end - utf8_buf));
+		    CAST(size_t, utf8_end - utf8_buf));
 
 		if ((rv = file_softmagic(ms, &bb, NULL, NULL,
 		    TEXTTEST, text)) == 0)
@@ -330,42 +330,42 @@
 		if (ubuf[i] <= 0x7f) {
 			if (end - buf < 1)
 				return NULL;
-			*buf++ = (unsigned char)ubuf[i];
+			*buf++ = CAST(unsigned char, ubuf[i]);
 		} else if (ubuf[i] <= 0x7ff) {
 			if (end - buf < 2)
 				return NULL;
-			*buf++ = (unsigned char)((ubuf[i] >> 6) + 0xc0);
-			*buf++ = (unsigned char)((ubuf[i] & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] >> 6) + 0xc0);
+			*buf++ = CAST(unsigned char, (ubuf[i] & 0x3f) + 0x80);
 		} else if (ubuf[i] <= 0xffff) {
 			if (end - buf < 3)
 				return NULL;
-			*buf++ = (unsigned char)((ubuf[i] >> 12) + 0xe0);
-			*buf++ = (unsigned char)(((ubuf[i] >> 6) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)((ubuf[i] & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] >> 12) + 0xe0);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 6) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] & 0x3f) + 0x80);
 		} else if (ubuf[i] <= 0x1fffff) {
 			if (end - buf < 4)
 				return NULL;
-			*buf++ = (unsigned char)((ubuf[i] >> 18) + 0xf0);
-			*buf++ = (unsigned char)(((ubuf[i] >> 12) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)(((ubuf[i] >>  6) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)((ubuf[i] & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] >> 18) + 0xf0);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 12) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >>  6) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] & 0x3f) + 0x80);
 		} else if (ubuf[i] <= 0x3ffffff) {
 			if (end - buf < 5)
 				return NULL;
-			*buf++ = (unsigned char)((ubuf[i] >> 24) + 0xf8);
-			*buf++ = (unsigned char)(((ubuf[i] >> 18) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)(((ubuf[i] >> 12) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)(((ubuf[i] >>  6) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)((ubuf[i] & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] >> 24) + 0xf8);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 18) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 12) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >>  6) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] & 0x3f) + 0x80);
 		} else if (ubuf[i] <= 0x7fffffff) {
 			if (end - buf < 6)
 				return NULL;
-			*buf++ = (unsigned char)((ubuf[i] >> 30) + 0xfc);
-			*buf++ = (unsigned char)(((ubuf[i] >> 24) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)(((ubuf[i] >> 18) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)(((ubuf[i] >> 12) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)(((ubuf[i] >>  6) & 0x3f) + 0x80);
-			*buf++ = (unsigned char)((ubuf[i] & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] >> 30) + 0xfc);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 24) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 18) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >> 12) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, ((ubuf[i] >>  6) & 0x3f) + 0x80);
+			*buf++ = CAST(unsigned char, (ubuf[i] & 0x3f) + 0x80);
 		} else /* Invalid character */
 			return NULL;
 	}
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -61,13 +61,13 @@
 	struct buffer *b = CCAST(struct buffer *, bb);
 
 	if (b->elen != 0)
-		return b->elen == (size_t)~0 ? -1 : 0;
+		return b->elen == CAST(size_t, ~0) ? -1 : 0;
 
 	if (!S_ISREG(b->st.st_mode))
 		goto out;
 
-	b->elen =  (size_t)b->st.st_size < b->flen ?
-	    (size_t)b->st.st_size : b->flen;
+	b->elen =  CAST(size_t, b->st.st_size) < b->flen ?
+	    CAST(size_t, b->st.st_size) : b->flen;
 	if ((b->ebuf = malloc(b->elen)) == NULL)
 		goto out;
 
@@ -79,6 +79,6 @@
 
 	return 0;
 out:
-	b->elen = (size_t)~0;
+	b->elen = CAST(size_t, ~0);
 	return -1;
 }
--- a/src/cdf.c
+++ b/src/cdf.c
@@ -35,7 +35,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: cdf.c,v 1.113 2018/10/15 16:29:16 christos Exp $")
+FILE_RCSID("@(#)$File: cdf.c,v 1.114 2019/02/20 02:35:27 christos Exp $")
 #endif
 
 #include <assert.h>
@@ -66,11 +66,14 @@
 	uint32_t u;
 } cdf_bo;
 
-#define NEED_SWAP	(cdf_bo.u == (uint32_t)0x01020304)
+#define NEED_SWAP	(cdf_bo.u == CAST(uint32_t, 0x01020304))
 
-#define CDF_TOLE8(x)	((uint64_t)(NEED_SWAP ? _cdf_tole8(x) : (uint64_t)(x)))
-#define CDF_TOLE4(x)	((uint32_t)(NEED_SWAP ? _cdf_tole4(x) : (uint32_t)(x)))
-#define CDF_TOLE2(x)	((uint16_t)(NEED_SWAP ? _cdf_tole2(x) : (uint16_t)(x)))
+#define CDF_TOLE8(x)	\
+    (CAST(uint64_t, NEED_SWAP ? _cdf_tole8(x) : CAST(uint64_t, x)))
+#define CDF_TOLE4(x)	\
+    (CAST(uint32_t, NEED_SWAP ? _cdf_tole4(x) : CAST(uint32_t, x)))
+#define CDF_TOLE2(x)	\
+    (CAST(uint16_t, NEED_SWAP ? _cdf_tole2(x) : CAST(uint16_t, x)))
 #define CDF_TOLE(x)	(/*CONSTCOND*/sizeof(x) == 2 ? \
 			    CDF_TOLE2(CAST(uint16_t, x)) : \
 			(/*CONSTCOND*/sizeof(x) == 4 ? \
@@ -120,8 +123,8 @@
 _cdf_tole2(uint16_t sv)
 {
 	uint16_t rv;
-	uint8_t *s = (uint8_t *)(void *)&sv;
-	uint8_t *d = (uint8_t *)(void *)&rv;
+	uint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));
+	uint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));
 	d[0] = s[1];
 	d[1] = s[0];
 	return rv;
@@ -134,8 +137,8 @@
 _cdf_tole4(uint32_t sv)
 {
 	uint32_t rv;
-	uint8_t *s = (uint8_t *)(void *)&sv;
-	uint8_t *d = (uint8_t *)(void *)&rv;
+	uint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));
+	uint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));
 	d[0] = s[3];
 	d[1] = s[2];
 	d[2] = s[1];
@@ -150,8 +153,8 @@
 _cdf_tole8(uint64_t sv)
 {
 	uint64_t rv;
-	uint8_t *s = (uint8_t *)(void *)&sv;
-	uint8_t *d = (uint8_t *)(void *)&rv;
+	uint8_t *s = RCAST(uint8_t *, RCAST(void *, &sv));
+	uint8_t *d = RCAST(uint8_t *, RCAST(void *, &rv));
 	d[0] = s[7];
 	d[1] = s[6];
 	d[2] = s[5];
@@ -216,15 +219,17 @@
 	h->h_min_size_standard_stream =
 	    CDF_TOLE4(h->h_min_size_standard_stream);
 	h->h_secid_first_sector_in_short_sat =
-	    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_short_sat);
+	    CDF_TOLE4(CAST(uint32_t, h->h_secid_first_sector_in_short_sat));
 	h->h_num_sectors_in_short_sat =
 	    CDF_TOLE4(h->h_num_sectors_in_short_sat);
 	h->h_secid_first_sector_in_master_sat =
-	    CDF_TOLE4((uint32_t)h->h_secid_first_sector_in_master_sat);
+	    CDF_TOLE4(CAST(uint32_t, h->h_secid_first_sector_in_master_sat));
 	h->h_num_sectors_in_master_sat =
 	    CDF_TOLE4(h->h_num_sectors_in_master_sat);
-	for (i = 0; i < __arraycount(h->h_master_sat); i++)
-		h->h_master_sat[i] = CDF_TOLE4((uint32_t)h->h_master_sat[i]);
+	for (i = 0; i < __arraycount(h->h_master_sat); i++) {
+		h->h_master_sat[i] =
+		    CDF_TOLE4(CAST(uint32_t, h->h_master_sat[i]));
+	}
 }
 
 void
@@ -257,15 +262,16 @@
 cdf_swap_dir(cdf_directory_t *d)
 {
 	d->d_namelen = CDF_TOLE2(d->d_namelen);
-	d->d_left_child = CDF_TOLE4((uint32_t)d->d_left_child);
-	d->d_right_child = CDF_TOLE4((uint32_t)d->d_right_child);
-	d->d_storage = CDF_TOLE4((uint32_t)d->d_storage);
+	d->d_left_child = CDF_TOLE4(CAST(uint32_t, d->d_left_child));
+	d->d_right_child = CDF_TOLE4(CAST(uint32_t, d->d_right_child));
+	d->d_storage = CDF_TOLE4(CAST(uint32_t, d->d_storage));
 	d->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);
 	d->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);
 	d->d_flags = CDF_TOLE4(d->d_flags);
-	d->d_created = CDF_TOLE8((uint64_t)d->d_created);
-	d->d_modified = CDF_TOLE8((uint64_t)d->d_modified);
-	d->d_stream_first_sector = CDF_TOLE4((uint32_t)d->d_stream_first_sector);
+	d->d_created = CDF_TOLE8(CAST(uint64_t, d->d_created));
+	d->d_modified = CDF_TOLE8(CAST(uint64_t, d->d_modified));
+	d->d_stream_first_sector = CDF_TOLE4(
+	    CAST(uint32_t, d->d_stream_first_sector));
 	d->d_size = CDF_TOLE4(d->d_size);
 }
 
@@ -322,11 +328,11 @@
 cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,
     const void *p, size_t tail, int line)
 {
-	const char *b = (const char *)sst->sst_tab;
-	const char *e = ((const char *)p) + tail;
+	const char *b = RCAST(const char *, sst->sst_tab);
+	const char *e = RCAST(const char *, p) + tail;
 	size_t ss = cdf_check_stream(sst, h);
 	/*LINTED*/(void)&line;
-	if (e >= b && (size_t)(e - b) <= ss * sst->sst_len)
+	if (e >= b && CAST(size_t, e - b) <= ss * sst->sst_len)
 		return 0;
 	DPRINTF(("%d: offset begin %p < end %p || %" SIZE_T_FORMAT "u"
 	    " > %" SIZE_T_FORMAT "u [%" SIZE_T_FORMAT "u %"
@@ -339,23 +345,23 @@
 static ssize_t
 cdf_read(const cdf_info_t *info, off_t off, void *buf, size_t len)
 {
-	size_t siz = (size_t)off + len;
+	size_t siz = CAST(size_t, off + len);
 
-	if ((off_t)(off + len) != (off_t)siz)
+	if (CAST(off_t, off + len) != CAST(off_t, siz))
 		goto out;
 
 	if (info->i_buf != NULL && info->i_len >= siz) {
 		(void)memcpy(buf, &info->i_buf[off], len);
-		return (ssize_t)len;
+		return CAST(ssize_t, len);
 	}
 
 	if (info->i_fd == -1)
 		goto out;
 
-	if (pread(info->i_fd, buf, len, off) != (ssize_t)len)
+	if (pread(info->i_fd, buf, len, off) != CAST(ssize_t, len))
 		return -1;
 
-	return (ssize_t)len;
+	return CAST(ssize_t, len);
 out:
 	errno = EINVAL;
 	return -1;
@@ -367,7 +373,7 @@
 	char buf[512];
 
 	(void)memcpy(cdf_bo.s, "\01\02\03\04", 4);
-	if (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)
+	if (cdf_read(info, CAST(off_t, 0), buf, sizeof(buf)) == -1)
 		return -1;
 	cdf_unpack_header(h, buf);
 	cdf_swap_header(h);
@@ -401,7 +407,7 @@
 	size_t ss = CDF_SEC_SIZE(h);
 	size_t pos = CDF_SEC_POS(h, id);
 	assert(ss == len);
-	return cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);
+	return cdf_read(info, CAST(off_t, pos), RCAST(char *, buf) + offs, len);
 }
 
 ssize_t
@@ -417,8 +423,8 @@
 		    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));
 		goto out;
 	}
-	(void)memcpy(((char *)buf) + offs,
-	    ((const char *)sst->sst_tab) + pos, len);
+	(void)memcpy(RCAST(char *, buf) + offs,
+	    RCAST(const char *, sst->sst_tab) + pos, len);
 	return len;
 out:
 	errno = EFTYPE;
@@ -461,7 +467,7 @@
 		if (h->h_master_sat[i] < 0)
 			break;
 		if (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,
-		    h->h_master_sat[i]) != (ssize_t)ss) {
+		    h->h_master_sat[i]) != CAST(ssize_t, ss)) {
 			DPRINTF(("Reading sector %d", h->h_master_sat[i]));
 			goto out1;
 		}
@@ -478,12 +484,13 @@
 			DPRINTF(("Reading master sector loop limit"));
 			goto out3;
 		}
-		if (cdf_read_sector(info, msa, 0, ss, h, mid) != (ssize_t)ss) {
+		if (cdf_read_sector(info, msa, 0, ss, h, mid) !=
+		    CAST(ssize_t, ss)) {
 			DPRINTF(("Reading master sector %d", mid));
 			goto out2;
 		}
 		for (k = 0; k < nsatpersec; k++, i++) {
-			sec = CDF_TOLE4((uint32_t)msa[k]);
+			sec = CDF_TOLE4(CAST(uint32_t, msa[k]));
 			if (sec < 0)
 				goto out;
 			if (i >= sat->sat_len) {
@@ -493,13 +500,13 @@
 			    goto out3;
 			}
 			if (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,
-			    sec) != (ssize_t)ss) {
+			    sec) != CAST(ssize_t, ss)) {
 				DPRINTF(("Reading sector %d",
 				    CDF_TOLE4(msa[k])));
 				goto out2;
 			}
 		}
-		mid = CDF_TOLE4((uint32_t)msa[nsatpersec]);
+		mid = CDF_TOLE4(CAST(uint32_t, msa[nsatpersec]));
 	}
 out:
 	sat->sat_len = i;
@@ -518,7 +525,7 @@
 cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)
 {
 	size_t i, j;
-	cdf_secid_t maxsector = (cdf_secid_t)((sat->sat_len * size)
+	cdf_secid_t maxsector = CAST(cdf_secid_t, (sat->sat_len * size)
 	    / sizeof(maxsector));
 
 	DPRINTF(("Chain:"));
@@ -538,7 +545,7 @@
 			DPRINTF(("Sector %d >= %d\n", sid, maxsector));
 			goto out;
 		}
-		sid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);
+		sid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));
 	}
 	if (i == 0) {
 		DPRINTF((" none, sid: %d\n", sid));
@@ -549,7 +556,7 @@
 	return i;
 out:
 	errno = EFTYPE;
-	return (size_t)-1;
+	return CAST(size_t, -1);
 }
 
 int
@@ -566,7 +573,7 @@
 	if (sid == CDF_SECID_END_OF_CHAIN || len == 0)
 		return cdf_zero_stream(scn);
 
-	if (scn->sst_len == (size_t)-1)
+	if (scn->sst_len == CAST(size_t, -1))
 		goto out;
 
 	scn->sst_tab = CDF_CALLOC(scn->sst_len, ss);
@@ -585,7 +592,7 @@
 			goto out;
 		}
 		if ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,
-		    sid)) != (ssize_t)ss) {
+		    sid)) != CAST(ssize_t, ss)) {
 			if (i == scn->sst_len - 1 && nr > 0) {
 				/* Last sector might be truncated */
 				return 0;
@@ -593,7 +600,7 @@
 			DPRINTF(("Reading long sector chain %d", sid));
 			goto out;
 		}
-		sid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);
+		sid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));
 	}
 	return 0;
 out:
@@ -612,7 +619,7 @@
 	scn->sst_dirlen = len;
 	scn->sst_ss = ss;
 
-	if (scn->sst_len == (size_t)-1)
+	if (scn->sst_len == CAST(size_t, -1))
 		goto out;
 
 	scn->sst_tab = CDF_CALLOC(scn->sst_len, ss);
@@ -631,11 +638,11 @@
 			goto out;
 		}
 		if (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,
-		    sid) != (ssize_t)ss) {
+		    sid) != CAST(ssize_t, ss)) {
 			DPRINTF(("Reading short sector chain %d", sid));
 			goto out;
 		}
-		sid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);
+		sid = CDF_TOLE4(CAST(uint32_t, ssat->sat_tab[sid]));
 	}
 	return 0;
 out:
@@ -666,7 +673,7 @@
 	cdf_secid_t sid = h->h_secid_first_directory;
 
 	ns = cdf_count_chain(sat, sid, ss);
-	if (ns == (size_t)-1)
+	if (ns == CAST(size_t, -1))
 		return -1;
 
 	nd = ss / CDF_DIRECTORY_SIZE;
@@ -687,7 +694,8 @@
 			DPRINTF(("Read dir loop limit"));
 			goto out;
 		}
-		if (cdf_read_sector(info, buf, 0, ss, h, sid) != (ssize_t)ss) {
+		if (cdf_read_sector(info, buf, 0, ss, h, sid) !=
+		    CAST(ssize_t, ss)) {
 			DPRINTF(("Reading directory sector %d", sid));
 			goto out;
 		}
@@ -695,7 +703,7 @@
 			cdf_unpack_dir(&dir->dir_tab[i * nd + j],
 			    &buf[j * CDF_DIRECTORY_SIZE]);
 		}
-		sid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);
+		sid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));
 	}
 	if (NEED_SWAP)
 		for (i = 0; i < dir->dir_len; i++)
@@ -720,7 +728,7 @@
 
 	ssat->sat_tab = NULL;
 	ssat->sat_len = cdf_count_chain(sat, sid, ss);
-	if (ssat->sat_len == (size_t)-1)
+	if (ssat->sat_len == CAST(size_t, -1))
 		goto out;
 
 	ssat->sat_tab = CAST(cdf_secid_t *, CDF_CALLOC(ssat->sat_len, ss));
@@ -739,11 +747,11 @@
 			goto out;
 		}
 		if (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=
-		    (ssize_t)ss) {
+		    CAST(ssize_t, ss)) {
 			DPRINTF(("Reading short sat sector %d", sid));
 			goto out1;
 		}
-		sid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);
+		sid = CDF_TOLE4(CAST(uint32_t, sat->sat_tab[sid]));
 	}
 	return 0;
 out:
@@ -793,7 +801,7 @@
 {
 	for (; l--; d++, s++)
 		if (*d != CDF_TOLE2(*s))
-			return (unsigned char)*d - CDF_TOLE2(*s);
+			return CAST(unsigned char, *d) - CDF_TOLE2(*s);
 	return 0;
 }
 
@@ -924,7 +932,7 @@
 	if (inp->pi_type & CDF_VECTOR)
 		return 0;
 
-	if ((size_t)(CAST(const char *, e) - CAST(const char *, p)) < len)
+	if (CAST(size_t, CAST(const char *, e) - CAST(const char *, p)) < len)
 		return 0;
 
 	(void)memcpy(&inp->pi_val, p, len);
@@ -1110,8 +1118,9 @@
 	const cdf_summary_info_header_t *si =
 	    CAST(const cdf_summary_info_header_t *, sst->sst_tab);
 	const cdf_section_declaration_t *sd =
-	    CAST(const cdf_section_declaration_t *, (const void *)
-	    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));
+	    CAST(const cdf_section_declaration_t *, RCAST(const void *,
+	    RCAST(const char *, sst->sst_tab)
+	    + CDF_SECTION_DECLARATION_OFFSET));
 
 	if (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||
 	    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)
@@ -1262,28 +1271,28 @@
 	int days, hours, mins, secs;
 
 	ts /= CDF_TIME_PREC;
-	secs = (int)(ts % 60);
+	secs = CAST(int, ts % 60);
 	ts /= 60;
-	mins = (int)(ts % 60);
+	mins = CAST(int, ts % 60);
 	ts /= 60;
-	hours = (int)(ts % 24);
+	hours = CAST(int, ts % 24);
 	ts /= 24;
-	days = (int)ts;
+	days = CAST(int, ts);
 
 	if (days) {
 		len += snprintf(buf + len, bufsiz - len, "%dd+", days);
-		if ((size_t)len >= bufsiz)
+		if (CAST(size_t, len) >= bufsiz)
 			return len;
 	}
 
 	if (days || hours) {
 		len += snprintf(buf + len, bufsiz - len, "%.2d:", hours);
-		if ((size_t)len >= bufsiz)
+		if (CAST(size_t, len) >= bufsiz)
 			return len;
 	}
 
 	len += snprintf(buf + len, bufsiz - len, "%.2d:", mins);
-	if ((size_t)len >= bufsiz)
+	if (CAST(size_t, len) >= bufsiz)
 		return len;
 
 	len += snprintf(buf + len, bufsiz - len, "%.2d", secs);
@@ -1295,7 +1304,7 @@
 {
 	size_t i;
 	for (i = 0; i < len && p[i]; i++)
-		buf[i] = (char)p[i];
+		buf[i] = CAST(char, p[i]);
 	buf[i] = '\0';
 	return buf;
 }
--- a/src/cdf.h
+++ b/src/cdf.h
@@ -76,9 +76,9 @@
 	cdf_secid_t	h_master_sat[436/4];
 } cdf_header_t;
 
-#define CDF_SEC_SIZE(h) ((size_t)(1 << (h)->h_sec_size_p2))
+#define CDF_SEC_SIZE(h) CAST(size_t, 1 << (h)->h_sec_size_p2)
 #define CDF_SEC_POS(h, secid) (CDF_SEC_SIZE(h) + (secid) * CDF_SEC_SIZE(h))
-#define CDF_SHORT_SEC_SIZE(h)	((size_t)(1 << (h)->h_short_sec_size_p2))
+#define CDF_SHORT_SEC_SIZE(h)	CAST(size_t, 1 << (h)->h_short_sec_size_p2)
 #define CDF_SHORT_SEC_POS(h, secid) ((secid) * CDF_SHORT_SEC_SIZE(h))
 
 typedef int32_t cdf_dirid_t;
--- a/src/cdf_time.c
+++ b/src/cdf_time.c
@@ -27,7 +27,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: cdf_time.c,v 1.17 2018/09/09 20:33:28 christos Exp $")
+FILE_RCSID("@(#)$File: cdf_time.c,v 1.18 2019/02/20 02:35:27 christos Exp $")
 #endif
 
 #include <time.h>
@@ -90,9 +90,9 @@
 		if (m == 1 && isleap(year))
 			days--;
 		if (days <= 0)
-			return (int)m;
+			return CAST(int, m);
 	}
-	return (int)m;
+	return CAST(int, m);
 }
 
 int
@@ -108,22 +108,22 @@
 	ts->tv_nsec = (t % CDF_TIME_PREC) * 100;
 
 	t /= CDF_TIME_PREC;
-	tm.tm_sec = (int)(t % 60);
+	tm.tm_sec = CAST(int, t % 60);
 	t /= 60;
 
-	tm.tm_min = (int)(t % 60);
+	tm.tm_min = CAST(int, t % 60);
 	t /= 60;
 
-	tm.tm_hour = (int)(t % 24);
+	tm.tm_hour = CAST(int, t % 24);
 	t /= 24;
 
 	/* XXX: Approx */
-	tm.tm_year = (int)(CDF_BASE_YEAR + (t / 365));
+	tm.tm_year = CAST(int, CDF_BASE_YEAR + (t / 365));
 
 	rdays = cdf_getdays(tm.tm_year);
 	t -= rdays - 1;
-	tm.tm_mday = cdf_getday(tm.tm_year, (int)t);
-	tm.tm_mon = cdf_getmonth(tm.tm_year, (int)t);
+	tm.tm_mday = cdf_getday(tm.tm_year, CAST(int, t));
+	tm.tm_mon = cdf_getmonth(tm.tm_year, CAST(int, t));
 	tm.tm_wday = 0;
 	tm.tm_yday = 0;
 	tm.tm_isdst = 0;
@@ -172,7 +172,7 @@
 	if (ptr != NULL)
 		return buf;
 	(void)snprintf(buf, 26, "*Bad* %#16.16" INT64_T_FORMAT "x\n",
-	    (long long)*sec);
+	    CAST(long long, *sec));
 	return buf;
 }
 
--- a/src/compress.c
+++ b/src/compress.c
@@ -378,7 +378,7 @@
 		(void)ioctl(fd, FIONREAD, &t);
 	}
 
-	if (t > 0 && (size_t)t < n) {
+	if (t > 0 && CAST(size_t, t) < n) {
 		n = t;
 		rn = n;
 	}
@@ -436,11 +436,11 @@
 		return -1;
 	}
 
-	if (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)
+	if (swrite(tfd, startbuf, nbytes) != CAST(ssize_t, nbytes))
 		r = 1;
 	else {
 		while ((r = sread(fd, buf, sizeof(buf), 1)) > 0)
-			if (swrite(tfd, buf, (size_t)r) != r)
+			if (swrite(tfd, buf, CAST(size_t, r)) != r)
 				break;
 	}
 
@@ -465,7 +465,7 @@
 		return -1;
 	}
 	(void)close(tfd);
-	if (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) {
+	if (lseek(fd, CAST(off_t, 0), SEEK_SET) == CAST(off_t, -1)) {
 		file_badseek(ms);
 		return -1;
 	}
@@ -542,7 +542,7 @@
 	if (rc != Z_OK && rc != Z_STREAM_END)
 		goto err;
 
-	*n = (size_t)z.total_out;
+	*n = CAST(size_t, z.total_out);
 	rc = inflateEnd(&z);
 	if (rc != Z_OK)
 		goto err;
@@ -552,8 +552,8 @@
 
 	return OKDATA;
 err:
-	strlcpy((char *)*newch, z.msg ? z.msg : zError(rc), bytes_max);
-	*n = strlen((char *)*newch);
+	strlcpy(RCAST(char *, *newch), z.msg ? z.msg : zError(rc), bytes_max);
+	*n = strlen(RCAST(char *, *newch));
 	return ERRDATA;
 }
 #endif
@@ -573,7 +573,7 @@
 		*len = 0;
 		return NODATA;
 	}
-	*buf = (unsigned char *)msg;
+	*buf = RCAST(unsigned char *, msg);
 	*len = strlen(msg);
 	return ERRDATA;
 }
@@ -621,7 +621,7 @@
 	switch (fork()) {
 	case 0: /* child */
 		closefd(fdp[STDOUT_FILENO], 0);
-		if (swrite(fdp[STDIN_FILENO][1], old, n) != (ssize_t)n) {
+		if (swrite(fdp[STDIN_FILENO][1], old, n) != CAST(ssize_t, n)) {
 			DPRINTF("Write failed (%s)\n", strerror(errno));
 			exit(1);
 		}
@@ -650,17 +650,17 @@
 	char *buf;
 
 	ubuf[n] = '\0';
-	buf = (char *)ubuf;
-	while (isspace((unsigned char)*buf))
+	buf = RCAST(char *, ubuf);
+	while (isspace(CAST(unsigned char, *buf)))
 		buf++;
 	DPRINTF("Filter error[[[%s]]]\n", buf);
-	if ((p = strchr((char *)buf, '\n')) != NULL)
+	if ((p = strchr(CAST(char *, buf), '\n')) != NULL)
 		*p = '\0';
-	if ((p = strchr((char *)buf, ';')) != NULL)
+	if ((p = strchr(CAST(char *, buf), ';')) != NULL)
 		*p = '\0';
-	if ((p = strrchr((char *)buf, ':')) != NULL) {
+	if ((p = strrchr(CAST(char *, buf), ':')) != NULL) {
 		++p;
-		while (isspace((unsigned char)*p))
+		while (isspace(CAST(unsigned char, *p)))
 			p++;
 		n = strlen(p);
 		memmove(ubuf, p, CAST(size_t, n + 1));
@@ -715,14 +715,14 @@
 	case 0:	/* child */
 		if (fd != -1) {
 			fdp[STDIN_FILENO][0] = fd;
-			(void) lseek(fd, (off_t)0, SEEK_SET);
+			(void) lseek(fd, CAST(off_t, 0), SEEK_SET);
 		}
 
 		for (i = 0; i < __arraycount(fdp); i++)
 			copydesc(CAST(int, i), fdp[i]);
 
 		(void)execvp(compr[method].argv[0],
-		    (char *const *)(intptr_t)compr[method].argv);
+		    RCAST(char *const *, RCAST(intptr_t, compr[method].argv)));
 		dprintf(STDERR_FILENO, "exec `%s' failed, %s",
 		    compr[method].argv[0], strerror(errno));
 		exit(1);
--- a/src/der.c
+++ b/src/der.c
@@ -35,7 +35,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: der.c,v 1.15 2018/10/15 16:29:16 christos Exp $")
+FILE_RCSID("@(#)$File: der.c,v 1.16 2019/02/20 02:35:27 christos Exp $")
 #endif
 #endif
 
@@ -56,7 +56,7 @@
 #include <err.h>
 #endif
 
-#define DER_BAD	((uint32_t)-1)
+#define DER_BAD	CAST(uint32_t, -1)
 
 #define DER_CLASS_UNIVERSAL	0
 #define	DER_CLASS_APPLICATION	1
@@ -224,7 +224,7 @@
 	case DER_TAG_UTF8_STRING:
 	case DER_TAG_IA5_STRING:
 	case DER_TAG_UTCTIME:
-		return snprintf(buf, blen, "%.*s", len, (const char *)q);
+		return snprintf(buf, blen, "%.*s", len, RCAST(const char *, q));
 	default:
 		break;
 	}
@@ -307,13 +307,13 @@
 		s++;
 		goto val;
 	default:
-		if (!isdigit((unsigned char)*s))
+		if (!isdigit(CAST(unsigned char, *s)))
 			return 0;
 
 		slen = 0;
 		do
 			slen = slen * 10 + *s - '0';
-		while (isdigit((unsigned char)*++s));
+		while (isdigit(CAST(unsigned char, *++s)));
 		if ((ms->flags & MAGIC_DEBUG) != 0)
 			fprintf(stderr, "%s: len %" SIZE_T_FORMAT "u %u\n",
 			    __func__, slen, tlen);
--- a/src/elfclass.h
+++ b/src/elfclass.h
@@ -41,8 +41,8 @@
 			return toomany(ms, "program headers", phnum);
 		flags |= FLAGS_IS_CORE;
 		if (dophn_core(ms, clazz, swap, fd,
-		    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,
-		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
+		    CAST(off_t, elf_getu(swap, elfhdr.e_phoff)), phnum,
+		    CAST(size_t, elf_getu16(swap, elfhdr.e_phentsize)),
 		    fsize, &flags, &notecount) == -1)
 			return -1;
 		break;
@@ -56,8 +56,8 @@
 		if (shnum > ms->elf_shnum_max)
 			return toomany(ms, "section", shnum);
 		if (dophn_exec(ms, clazz, swap, fd,
-		    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,
-		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
+		    CAST(off_t, elf_getu(swap, elfhdr.e_phoff)), phnum,
+		    CAST(size_t, elf_getu16(swap, elfhdr.e_phentsize)),
 		    fsize, shnum, &flags, &notecount) == -1)
 			return -1;
 		/*FALLTHROUGH*/
@@ -66,10 +66,10 @@
 		if (shnum > ms->elf_shnum_max)
 			return toomany(ms, "section headers", shnum);
 		if (doshn(ms, clazz, swap, fd,
-		    (off_t)elf_getu(swap, elfhdr.e_shoff), shnum,
-		    (size_t)elf_getu16(swap, elfhdr.e_shentsize),
+		    CAST(off_t, elf_getu(swap, elfhdr.e_shoff)), shnum,
+		    CAST(size_t, elf_getu16(swap, elfhdr.e_shentsize)),
 		    fsize, elf_getu16(swap, elfhdr.e_machine),
-		    (int)elf_getu16(swap, elfhdr.e_shstrndx),
+		    CAST(int, elf_getu16(swap, elfhdr.e_shstrndx)),
 		    &flags, &notecount) == -1)
 			return -1;
 		break;
--- a/src/encoding.c
+++ b/src/encoding.c
@@ -89,12 +89,12 @@
 	*code_mime = "binary";
 
 	mlen = (nbytes + 1) * sizeof((*ubuf)[0]);
-	if ((*ubuf = CAST(unichar *, calloc((size_t)1, mlen))) == NULL) {
+	if ((*ubuf = CAST(unichar *, calloc(CAST(size_t, 1), mlen))) == NULL) {
 		file_oomem(ms, mlen);
 		goto done;
 	}
 	mlen = (nbytes + 1) * sizeof(nbuf[0]);
-	if ((nbuf = CAST(unsigned char *, calloc((size_t)1, mlen))) == NULL) {
+	if ((nbuf = CAST(unsigned char *, calloc(CAST(size_t, 1), mlen))) == NULL) {
 		file_oomem(ms, mlen);
 		goto done;
 	}
@@ -449,7 +449,7 @@
 		if (ubf[*ulen - 1] == 0xfffe)
 			return 0;
 		if (ubf[*ulen - 1] < 128 &&
-		    text_chars[(size_t)ubf[*ulen - 1]] != T)
+		    text_chars[CAST(size_t, ubf[*ulen - 1])] != T)
 			return 0;
 	}
 
@@ -488,7 +488,7 @@
 		if (ubf[*ulen - 1] == 0xfffe)
 			return 0;
 		if (ubf[*ulen - 1] < 128 &&
-		    text_chars[(size_t)ubf[*ulen - 1]] != T)
+		    text_chars[CAST(size_t, ubf[*ulen - 1])] != T)
 			return 0;
 	}
 
--- a/src/file.c
+++ b/src/file.c
@@ -400,7 +400,8 @@
 	}
 	else {
 		size_t j, wid, nw;
-		for (wid = 0, j = (size_t)optind; j < (size_t)argc; j++) {
+		for (wid = 0, j = CAST(size_t, optind); j < CAST(size_t, argc);
+		    j++) {
 			nw = file_mbswidth(argv[j]);
 			if (nw > wid)
 				wid = nw;
@@ -537,9 +538,8 @@
 			(void)putc('\0', stdout);
 		if (nulsep < 2) {
 			(void)printf("%s", separator);
-			(void)printf("%*s ",
-			    (int) (nopad ? 0 : (wid - file_mbswidth(inname))),
-			    "");
+			(void)printf("%*s ", CAST(int, nopad ? 0
+			    : (wid - file_mbswidth(inname))), "");
 		}
 	}
 
@@ -566,8 +566,8 @@
 
 	while (n > 0) {
 		bytesconsumed = mbrtowc(&nextchar, s, n, &state);
-		if (bytesconsumed == (size_t)(-1) ||
-		    bytesconsumed == (size_t)(-2)) {
+		if (bytesconsumed == CAST(size_t, -1) ||
+		    bytesconsumed == CAST(size_t, -2)) {
 			/* Something went wrong, return something reasonable */
 			return old_n;
 		}
@@ -626,13 +626,13 @@
 	for (sp = p - 1; sp > opts && *sp == ' '; sp--)
 		continue;
 
-	fprintf(stdout, "%.*s", (int)(p - opts), opts);
+	fprintf(stdout, "%.*s", CAST(int, p - opts), opts);
 
 	comma = 0;
 	for (i = 0; i < __arraycount(nv); i++) {
 		fprintf(stdout, "%s%s", comma++ ? ", " : "", nv[i].name);
 		if (i && i % 5 == 0 && i != __arraycount(nv) - 1) {
-			fprintf(stdout, ",\n%*s", (int)(p - sp - 1), "");
+			fprintf(stdout, ",\n%*s", CAST(int, p - sp - 1), "");
 			comma = 0;
 		}
 	}
--- a/src/funcs.c
+++ b/src/funcs.c
@@ -392,9 +392,9 @@
 #define OCTALIFY(n, o)	\
 	/*LINTED*/ \
 	(void)(*(n)++ = '\\', \
-	*(n)++ = (((uint32_t)*(o) >> 6) & 3) + '0', \
-	*(n)++ = (((uint32_t)*(o) >> 3) & 7) + '0', \
-	*(n)++ = (((uint32_t)*(o) >> 0) & 7) + '0', \
+	*(n)++ = ((CAST(uint32_t, *(o)) >> 6) & 3) + '0', \
+	*(n)++ = ((CAST(uint32_t, *(o)) >> 3) & 7) + '0', \
+	*(n)++ = ((CAST(uint32_t, *(o)) >> 0) & 7) + '0', \
 	(o)++)
 
 protected const char *
@@ -440,9 +440,9 @@
 
 		while (op < eop) {
 			bytesconsumed = mbrtowc(&nextchar, op,
-			    (size_t)(eop - op), &state);
-			if (bytesconsumed == (size_t)(-1) ||
-			    bytesconsumed == (size_t)(-2)) {
+			    CAST(size_t, eop - op), &state);
+			if (bytesconsumed == CAST(size_t, -1) ||
+			    bytesconsumed == CAST(size_t, -2)) {
 				mb_conv = 0;
 				break;
 			}
@@ -465,7 +465,7 @@
 #endif
 
 	for (np = ms->o.pbuf, op = ms->o.buf; *op;) {
-		if (isprint((unsigned char)*op)) {
+		if (isprint(CAST(unsigned char, *op))) {
 			*np++ = *op++;
 		} else {
 			OCTALIFY(np, op);
@@ -626,7 +626,7 @@
 file_printable(char *buf, size_t bufsiz, const char *str, size_t slen)
 {
 	char *ptr, *eptr = buf + bufsiz - 1;
-	const unsigned char *s = (const unsigned char *)str;
+	const unsigned char *s = RCAST(const unsigned char *, str);
 	const unsigned char *es = s + slen;
 
 	for (ptr = buf;  ptr < eptr && s < es && *s; s++) {
--- a/src/is_tar.c
+++ b/src/is_tar.c
@@ -40,7 +40,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: is_tar.c,v 1.43 2018/10/15 16:29:16 christos Exp $")
+FILE_RCSID("@(#)$File: is_tar.c,v 1.44 2019/02/20 02:35:27 christos Exp $")
 #endif
 
 #include "magic.h"
@@ -98,7 +98,8 @@
 private int
 is_tar(const unsigned char *buf, size_t nbytes)
 {
-	const union record *header = (const union record *)(const void *)buf;
+	const union record *header = RCAST(const union record *,
+	    RCAST(const void *, buf));
 	size_t i;
 	int sum, recsum;
 	const unsigned char *p, *ep;
@@ -147,7 +148,7 @@
 	if (digs == 0)
 		return -1;
 
-	while (isspace((unsigned char)*where)) {	/* Skip spaces */
+	while (isspace(CAST(unsigned char, *where))) {	/* Skip spaces */
 		where++;
 		if (digs-- == 0)
 			return -1;		/* All blank field */
@@ -158,7 +159,7 @@
 		digs--;
 	}
 
-	if (digs > 0 && *where && !isspace((unsigned char)*where))
+	if (digs > 0 && *where && !isspace(CAST(unsigned char, *where)))
 		return -1;			/* Ended on non-(space/NUL) */
 
 	return value;
--- a/src/magic.c
+++ b/src/magic.c
@@ -312,7 +312,8 @@
 {
 	if (ms == NULL)
 		return -1;
-	return buffer_apprentice(ms, (struct magic **)bufs, sizes, nbufs);
+	return buffer_apprentice(ms, RCAST(struct magic **, bufs),
+	    sizes, nbufs);
 }
 #endif
 
@@ -405,7 +406,7 @@
 	struct stat	sb;
 	ssize_t nbytes = 0;	/* number of bytes read from a datafile */
 	int	ispipe = 0;
-	off_t	pos = (off_t)-1;
+	off_t	pos = CAST(off_t, -1);
 
 	if (file_reset(ms, 1) == -1)
 		goto out;
@@ -464,7 +465,7 @@
 		if (fstat(fd, &sb) == 0 && S_ISFIFO(sb.st_mode))
 			ispipe = 1;
 		if (inname == NULL)
-			pos = lseek(fd, (off_t)0, SEEK_CUR);
+			pos = lseek(fd, CAST(off_t, 0), SEEK_CUR);
 	}
 
 	/*
@@ -473,8 +474,8 @@
 	if (ispipe) {
 		ssize_t r = 0;
 
-		while ((r = sread(fd, (void *)&buf[nbytes],
-		    (size_t)(ms->bytes_max - nbytes), 1)) > 0) {
+		while ((r = sread(fd, RCAST(void *, &buf[nbytes]),
+		    CAST(size_t, ms->bytes_max - nbytes), 1)) > 0) {
 			nbytes += r;
 			if (r < PIPE_BUF) break;
 		}
@@ -494,7 +495,7 @@
 				_isatty(fd) ? 8 * 1024 :
 #endif
 				ms->bytes_max;
-		if ((nbytes = read(fd, (char *)buf, howmany)) == -1) {
+		if ((nbytes = read(fd, RCAST(void *, buf), howmany)) == -1) {
 			if (inname == NULL && fd != STDIN_FILENO)
 				file_error(ms, errno, "cannot read fd %d", fd);
 			else
@@ -505,13 +506,13 @@
 	}
 
 	(void)memset(buf + nbytes, 0, SLOP); /* NUL terminate */
-	if (file_buffer(ms, fd, inname, buf, (size_t)nbytes) == -1)
+	if (file_buffer(ms, fd, inname, buf, CAST(size_t, nbytes)) == -1)
 		goto done;
 	rv = 0;
 done:
 	free(buf);
 	if (fd != -1) {
-		if (pos != (off_t)-1)
+		if (pos != CAST(off_t, -1))
 			(void)lseek(fd, pos, SEEK_SET);
 		close_and_restore(ms, inname, fd, &sb);
 	}
@@ -589,25 +590,25 @@
 		return -1;
 	switch (param) {
 	case MAGIC_PARAM_INDIR_MAX:
-		ms->indir_max = (uint16_t)*(const size_t *)val;
+		ms->indir_max = CAST(uint16_t, *CAST(const size_t *, val));
 		return 0;
 	case MAGIC_PARAM_NAME_MAX:
-		ms->name_max = (uint16_t)*(const size_t *)val;
+		ms->name_max = CAST(uint16_t, *CAST(const size_t *, val));
 		return 0;
 	case MAGIC_PARAM_ELF_PHNUM_MAX:
-		ms->elf_phnum_max = (uint16_t)*(const size_t *)val;
+		ms->elf_phnum_max = CAST(uint16_t, *CAST(const size_t *, val));
 		return 0;
 	case MAGIC_PARAM_ELF_SHNUM_MAX:
-		ms->elf_shnum_max = (uint16_t)*(const size_t *)val;
+		ms->elf_shnum_max = CAST(uint16_t, *CAST(const size_t *, val));
 		return 0;
 	case MAGIC_PARAM_ELF_NOTES_MAX:
-		ms->elf_notes_max = (uint16_t)*(const size_t *)val;
+		ms->elf_notes_max = CAST(uint16_t, *CAST(const size_t *, val));
 		return 0;
 	case MAGIC_PARAM_REGEX_MAX:
-		ms->regex_max = (uint16_t)*(const size_t *)val;
+		ms->regex_max = CAST(uint16_t, *CAST(const size_t *, val));
 		return 0;
 	case MAGIC_PARAM_BYTES_MAX:
-		ms->bytes_max = *(const size_t *)val;
+		ms->bytes_max = *CAST(const size_t *, val);
 		return 0;
 	default:
 		errno = EINVAL;
@@ -622,25 +623,25 @@
 		return -1;
 	switch (param) {
 	case MAGIC_PARAM_INDIR_MAX:
-		*(size_t *)val = ms->indir_max;
+		*CAST(size_t *, val) = ms->indir_max;
 		return 0;
 	case MAGIC_PARAM_NAME_MAX:
-		*(size_t *)val = ms->name_max;
+		*CAST(size_t *, val) = ms->name_max;
 		return 0;
 	case MAGIC_PARAM_ELF_PHNUM_MAX:
-		*(size_t *)val = ms->elf_phnum_max;
+		*CAST(size_t *, val) = ms->elf_phnum_max;
 		return 0;
 	case MAGIC_PARAM_ELF_SHNUM_MAX:
-		*(size_t *)val = ms->elf_shnum_max;
+		*CAST(size_t *, val) = ms->elf_shnum_max;
 		return 0;
 	case MAGIC_PARAM_ELF_NOTES_MAX:
-		*(size_t *)val = ms->elf_notes_max;
+		*CAST(size_t *, val) = ms->elf_notes_max;
 		return 0;
 	case MAGIC_PARAM_REGEX_MAX:
-		*(size_t *)val = ms->regex_max;
+		*CAST(size_t *, val) = ms->regex_max;
 		return 0;
 	case MAGIC_PARAM_BYTES_MAX:
-		*(size_t *)val = ms->bytes_max;
+		*CAST(size_t *, val) = ms->bytes_max;
 		return 0;
 	default:
 		errno = EINVAL;
--- a/src/print.c
+++ b/src/print.c
@@ -32,7 +32,7 @@
 #include "file.h"
 
 #ifndef lint
-FILE_RCSID("@(#)$File: print.c,v 1.83 2018/09/09 20:33:28 christos Exp $")
+FILE_RCSID("@(#)$File: print.c,v 1.84 2019/02/20 02:35:27 christos Exp $")
 #endif  /* lint */
 
 #include <string.h>
@@ -65,7 +65,7 @@
 		if (m->in_op & FILE_OPINVERSE)
 			(void) fputc('~', stderr);
 		(void) fprintf(stderr, "%c%u),",
-		    ((size_t)(m->in_op & FILE_OPS_MASK) <
+		    (CAST(size_t, m->in_op & FILE_OPS_MASK) <
 		    SZOF(optyp)) ? optyp[m->in_op & FILE_OPS_MASK] : '?',
 		    m->in_offset);
 	}
@@ -112,14 +112,14 @@
 			(void) fprintf(stderr, "/%u", m->str_range);
 	}
 	else {
-		if ((size_t)(m->mask_op & FILE_OPS_MASK) < SZOF(optyp))
+		if (CAST(size_t, m->mask_op & FILE_OPS_MASK) < SZOF(optyp))
 			(void) fputc(optyp[m->mask_op & FILE_OPS_MASK], stderr);
 		else
 			(void) fputc('?', stderr);
 
 		if (m->num_mask) {
 			(void) fprintf(stderr, "%.8llx",
-			    (unsigned long long)m->num_mask);
+			    CAST(unsigned long long, m->num_mask));
 		}
 	}
 	(void) fprintf(stderr, ",%c", m->reln);
@@ -141,7 +141,7 @@
 		case FILE_LEQUAD:
 		case FILE_QUAD:
 			(void) fprintf(stderr, "%" INT64_T_FORMAT "d",
-			    (unsigned long long)m->value.q);
+			    CAST(long long, m->value.q));
 			break;
 		case FILE_PSTRING:
 		case FILE_STRING:
@@ -149,7 +149,8 @@
 		case FILE_BESTRING16:
 		case FILE_LESTRING16:
 		case FILE_SEARCH:
-			file_showstr(stderr, m->value.s, (size_t)m->vallen);
+			file_showstr(stderr, m->value.s,
+			    CAST(size_t, m->vallen));
 			break;
 		case FILE_DATE:
 		case FILE_LEDATE:
@@ -221,7 +222,7 @@
 
 	if (ms->file)
 		(void) fprintf(stderr, "%s, %lu: ", ms->file,
-		    (unsigned long)ms->line);
+		    CAST(unsigned long, ms->line));
 	(void) fprintf(stderr, "Warning: ");
 	va_start(va, f);
 	(void) vfprintf(stderr, f, va);
@@ -243,7 +244,7 @@
 	} else {
 		// XXX: perhaps detect and print something if overflow
 		// on 32 bit time_t?
-		t = (time_t)v;
+		t = CAST(time_t, v);
 	}
 
 	if (flags & FILE_T_LOCAL) {
--- a/src/readcdf.c
+++ b/src/readcdf.c
@@ -204,7 +204,7 @@
 				    && len--; s += k) {
 					if (*s == '\0')
 						break;
-					if (isprint((unsigned char)*s))
+					if (isprint(CAST(unsigned char, *s)))
 						vbuf[j++] = *s;
 				}
 				if (j == sizeof(vbuf))
@@ -318,19 +318,19 @@
 		case 2:
 			if (file_printf(ms, ", Os: Windows, Version %d.%d",
 			    si.si_os_version & 0xff,
-			    (uint32_t)si.si_os_version >> 8) == -1)
+			    CAST(uint32_t, si.si_os_version) >> 8) == -1)
 				return -2;
 			break;
 		case 1:
 			if (file_printf(ms, ", Os: MacOS, Version %d.%d",
-			    (uint32_t)si.si_os_version >> 8,
+			    CAST(uint32_t, si.si_os_version) >> 8,
 			    si.si_os_version & 0xff) == -1)
 				return -2;
 			break;
 		default:
 			if (file_printf(ms, ", Os %d, Version: %d.%d", si.si_os,
 			    si.si_os_version & 0xff,
-			    (uint32_t)si.si_os_version >> 8) == -1)
+			    CAST(uint32_t, si.si_os_version) >> 8) == -1)
 				return -2;
 			break;
 		}
@@ -406,7 +406,7 @@
 	for (j = 0; str == NULL && j < dir->dir_len; j++) {
 		d = &dir->dir_tab[j];
 		for (k = 0; k < sizeof(name); k++)
-			name[k] = (char)cdf_tole2(d->d_name[k]);
+			name[k] = CAST(char, cdf_tole2(d->d_name[k]));
 		str = cdf_app_to_mime(name,
 				      NOTMIME(ms) ? name2desc : name2mime);
 	}
--- a/src/readelf.c
+++ b/src/readelf.c
@@ -393,9 +393,9 @@
 		}
 		offset = 0;
 		for (;;) {
-			if (offset >= (size_t)bufsize)
+			if (offset >= CAST(size_t, bufsize))
 				break;
-			offset = donote(ms, nbuf, offset, (size_t)bufsize,
+			offset = donote(ms, nbuf, offset, CAST(size_t, bufsize),
 			    clazz, swap, 4, flags, notecount, fd, ph_off,
 			    ph_num, fsize);
 			if (offset == 0)
@@ -533,7 +533,7 @@
     int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,
     size_t noff, size_t doff, int *flags)
 {
-	if (namesz == 4 && strcmp((char *)&nbuf[noff], "GNU") == 0 &&
+	if (namesz == 4 && strcmp(RCAST(char *, &nbuf[noff]), "GNU") == 0 &&
 	    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {
 		uint8_t desc[20];
 		const char *btype;
@@ -561,10 +561,10 @@
 			return 1;
 		return 1;
 	}
-	if (namesz == 4 && strcmp((char *)&nbuf[noff], "Go") == 0 &&
+	if (namesz == 4 && strcmp(RCAST(char *, &nbuf[noff]), "Go") == 0 &&
 	    type == NT_GO_BUILD_ID && descsz < 128) {
 		if (file_printf(ms, ", Go BuildID=%.*s",
-		    CAST(int, descsz), CAST(char *, &nbuf[doff])) == -1)
+		    CAST(int, descsz), RCAST(char *, &nbuf[doff])) == -1)
 			return -1;
 		return 1;
 	}
@@ -576,7 +576,9 @@
     int swap, uint32_t namesz, uint32_t descsz,
     size_t noff, size_t doff, int *flags)
 {
-	if (namesz == 5 && strcmp((char *)&nbuf[noff], "SuSE") == 0 &&
+	const char *name = RCAST(const char *, &nbuf[noff]);
+
+	if (namesz == 5 && strcmp(name, "SuSE") == 0 &&
 		type == NT_GNU_VERSION && descsz == 2) {
 		*flags |= FLAGS_DID_OS_NOTE;
 		if (file_printf(ms, ", for SuSE %d.%d", nbuf[doff],
@@ -585,7 +587,7 @@
 	    return 1;
 	}
 
-	if (namesz == 4 && strcmp((char *)&nbuf[noff], "GNU") == 0 &&
+	if (namesz == 4 && strcmp(name, "GNU") == 0 &&
 	    type == NT_GNU_VERSION && descsz == 16) {
 		uint32_t desc[4];
 		memcpy(desc, &nbuf[doff], sizeof(desc));
@@ -624,7 +626,7 @@
 		return 1;
 	}
 
-	if (namesz == 7 && strcmp((char *)&nbuf[noff], "NetBSD") == 0) {
+	if (namesz == 7 && strcmp(name, "NetBSD") == 0) {
 	    	if (type == NT_NETBSD_VERSION && descsz == 4) {
 			*flags |= FLAGS_DID_OS_NOTE;
 			do_note_netbsd_version(ms, swap, &nbuf[doff]);
@@ -632,7 +634,7 @@
 		}
 	}
 
-	if (namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0) {
+	if (namesz == 8 && strcmp(name, "FreeBSD") == 0) {
 	    	if (type == NT_FREEBSD_VERSION && descsz == 4) {
 			*flags |= FLAGS_DID_OS_NOTE;
 			do_note_freebsd_version(ms, swap, &nbuf[doff]);
@@ -640,7 +642,7 @@
 		}
 	}
 
-	if (namesz == 8 && strcmp((char *)&nbuf[noff], "OpenBSD") == 0 &&
+	if (namesz == 8 && strcmp(name, "OpenBSD") == 0 &&
 	    type == NT_OPENBSD_VERSION && descsz == 4) {
 		*flags |= FLAGS_DID_OS_NOTE;
 		if (file_printf(ms, ", for OpenBSD") == -1)
@@ -649,7 +651,7 @@
 		return 1;
 	}
 
-	if (namesz == 10 && strcmp((char *)&nbuf[noff], "DragonFly") == 0 &&
+	if (namesz == 10 && strcmp(name, "DragonFly") == 0 &&
 	    type == NT_DRAGONFLY_VERSION && descsz == 4) {
 		uint32_t desc;
 		*flags |= FLAGS_DID_OS_NOTE;
@@ -670,7 +672,9 @@
     int swap, uint32_t namesz, uint32_t descsz,
     size_t noff, size_t doff, int *flags)
 {
-	if (namesz == 4 && strcmp((char *)&nbuf[noff], "PaX") == 0 &&
+	const char *name = RCAST(const char *, &nbuf[noff]);
+
+	if (namesz == 4 && strcmp(name, "PaX") == 0 &&
 	    type == NT_NETBSD_PAX && descsz == 4) {
 		static const char *pax[] = {
 		    "+mprotect",
@@ -692,7 +696,7 @@
 			return 1;
 
 		for (i = 0; i < __arraycount(pax); i++) {
-			if (((1 << (int)i) & desc) == 0)
+			if (((1 << CAST(int, i)) & desc) == 0)
 				continue;
 			if (file_printf(ms, "%s%s", did++ ? "," : "",
 			    pax[i]) == -1)
@@ -709,6 +713,8 @@
     size_t noff, size_t doff, int *flags, size_t size, int clazz)
 {
 #ifdef ELFCORE
+	const char *name = RCAST(const char *, &nbuf[noff]);
+
 	int os_style = -1;
 	/*
 	 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
@@ -724,16 +730,16 @@
 	 * doesn't include the terminating null in the
 	 * name....
 	 */
-	if ((namesz == 4 && strncmp((char *)&nbuf[noff], "CORE", 4) == 0) ||
-	    (namesz == 5 && strcmp((char *)&nbuf[noff], "CORE") == 0)) {
+	if ((namesz == 4 && strncmp(name, "CORE", 4) == 0) ||
+	    (namesz == 5 && strcmp(name, "CORE") == 0)) {
 		os_style = OS_STYLE_SVR4;
 	}
 
-	if ((namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0)) {
+	if ((namesz == 8 && strcmp(name, "FreeBSD") == 0)) {
 		os_style = OS_STYLE_FREEBSD;
 	}
 
-	if ((namesz >= 11 && strncmp((char *)&nbuf[noff], "NetBSD-CORE", 11)
+	if ((namesz >= 11 && strncmp(name, "NetBSD-CORE", 11)
 	    == 0)) {
 		os_style = OS_STYLE_NETBSD;
 	}
@@ -758,11 +764,11 @@
 			    "gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)",
 			    file_printable(sbuf, sizeof(sbuf),
 			    RCAST(char *, pi.cpi_name), sizeof(pi.cpi_name)),
-			    elf_getu32(swap, (uint32_t)pi.cpi_pid),
+			    elf_getu32(swap, CAST(uint32_t, pi.cpi_pid)),
 			    elf_getu32(swap, pi.cpi_euid),
 			    elf_getu32(swap, pi.cpi_egid),
 			    elf_getu32(swap, pi.cpi_nlwps),
-			    elf_getu32(swap, (uint32_t)pi.cpi_siglwp),
+			    elf_getu32(swap, CAST(uint32_t, pi.cpi_siglwp)),
 			    elf_getu32(swap, pi.cpi_signo),
 			    elf_getu32(swap, pi.cpi_sigcode)) == -1)
 				return 1;
@@ -876,8 +882,8 @@
 						i = k;
 				}
 
-				cname = (unsigned char *)
-				    &nbuf[doff + prpsoffsets(i)];
+				cname = CAST(unsigned char *,
+				    &nbuf[doff + prpsoffsets(i)]);
 				for (cp = cname; cp < nbuf + size && *cp
 				    && isprint(*cp); cp++)
 					continue;
@@ -888,7 +894,7 @@
 				while (cp > cname && isspace(cp[-1]))
 					cp--;
 				if (file_printf(ms, ", from '%.*s'",
-				    (int)(cp - cname), cname) == -1)
+				    CAST(int, cp - cname), cname) == -1)
 					return 1;
 				*flags |= FLAGS_DID_CORE;
 				return 1;
@@ -915,7 +921,8 @@
 	 * virtual address in which the "virtaddr" belongs to.
 	 */
 	for ( ; num; num--) {
-		if (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {
+		if (pread(fd, xph_addr, xph_sizeof, off) <
+		    CAST(ssize_t, xph_sizeof)) {
 			file_badread(ms);
 			return -1;
 		}
@@ -955,7 +962,7 @@
 
 	/* We expect only printable characters, so return if buffer contains
 	 * non-printable character before the '\0' or just '\0'. */
-	for (bptr = buf; *bptr && isprint((unsigned char)*bptr); bptr++)
+	for (bptr = buf; *bptr && isprint(CAST(unsigned char, *bptr)); bptr++)
 		continue;
 	if (*bptr != '\0')
 		return 0;
@@ -1061,8 +1068,8 @@
 			if (file_printf(ms, ", %s: '%s'", tag, buf) == -1)
 				return 0;
 		} else {
-			if (file_printf(ms, ", %s: %d", tag, (int) xauxv_val)
-			    == -1)
+			if (file_printf(ms, ", %s: %d", tag,
+			    CAST(int, xauxv_val)) == -1)
 				return 0;
 		}
 	}
@@ -1656,7 +1663,7 @@
 		case PT_DYNAMIC:
 			offset = 0;
 			for (;;) {
-				if (offset >= (size_t)bufsize)
+				if (offset >= CAST(size_t, bufsize))
 					break;
 				offset = dodynamic(ms, nbuf, offset,
 				    CAST(size_t, bufsize), clazz, swap);
@@ -1668,7 +1675,7 @@
 		case PT_INTERP:
 			if (bufsize && nbuf[0]) {
 				nbuf[bufsize - 1] = '\0';
-				memcpy(interp, nbuf, (size_t)bufsize);
+				memcpy(interp, nbuf, CAST(size_t, bufsize));
 			} else
 				strlcpy(interp, "*empty*", sizeof(interp));
 			break;
@@ -1679,7 +1686,7 @@
 			 */
 			offset = 0;
 			for (;;) {
-				if (offset >= (size_t)bufsize)
+				if (offset >= CAST(size_t, bufsize))
 					break;
 				offset = donote(ms, nbuf, offset,
 				    CAST(size_t, bufsize), clazz, swap, align,
--- a/src/softmagic.c
+++ b/src/softmagic.c
@@ -67,24 +67,46 @@
 private int cvt_32(union VALUETYPE *, const struct magic *);
 private int cvt_64(union VALUETYPE *, const struct magic *);
 
-#define OFFSET_OOB(n, o, i)	((n) < (uint32_t)(o) || (i) > ((n) - (o)))
-#define BE64(p) (((uint64_t)(p)->hq[0]<<56)|((uint64_t)(p)->hq[1]<<48)| \
-    ((uint64_t)(p)->hq[2]<<40)|((uint64_t)(p)->hq[3]<<32)| \
-    ((uint64_t)(p)->hq[4]<<24)|((uint64_t)(p)->hq[5]<<16)| \
-    ((uint64_t)(p)->hq[6]<<8)|((uint64_t)(p)->hq[7]))
-#define LE64(p) (((uint64_t)(p)->hq[7]<<56)|((uint64_t)(p)->hq[6]<<48)| \
-    ((uint64_t)(p)->hq[5]<<40)|((uint64_t)(p)->hq[4]<<32)| \
-    ((uint64_t)(p)->hq[3]<<24)|((uint64_t)(p)->hq[2]<<16)| \
-    ((uint64_t)(p)->hq[1]<<8)|((uint64_t)(p)->hq[0]))
-#define LE32(p) (((uint32_t)(p)->hl[3]<<24)|((uint32_t)(p)->hl[2]<<16)| \
-     ((uint32_t)(p)->hl[1]<<8)|((uint32_t)(p)->hl[0]))
-#define BE32(p) (((uint32_t)(p)->hl[0]<<24)|((uint32_t)(p)->hl[1]<<16)| \
-     ((uint32_t)(p)->hl[2]<<8)|((uint32_t)(p)->hl[3]))
-#define ME32(p) (((uint32_t)(p)->hl[1]<<24)|((uint32_t)(p)->hl[0]<<16)| \
-     ((uint32_t)(p)->hl[3]<<8)|((uint32_t)(p)->hl[2]))
-#define BE16(p) (((uint16_t)(p)->hs[0]<<8)|((uint16_t)(p)->hs[1]))
-#define LE16(p) (((uint16_t)(p)->hs[1]<<8)|((uint16_t)(p)->hs[0]))
-#define SEXT(s,v,p) ((s)?(intmax_t)(int##v##_t)(p):(intmax_t)(uint##v##_t)(p))
+#define OFFSET_OOB(n, o, i)	((n) < CAST(uint32_t, (o)) || (i) > ((n) - (o)))
+#define BE64(p) ( \
+    (CAST(uint64_t, (p)->hq[0])<<56)| \
+    (CAST(uint64_t, (p)->hq[1])<<48)| \
+    (CAST(uint64_t, (p)->hq[2])<<40)| \
+    (CAST(uint64_t, (p)->hq[3])<<32)| \
+    (CAST(uint64_t, (p)->hq[4])<<24)| \
+    (CAST(uint64_t, (p)->hq[5])<<16)| \
+    (CAST(uint64_t, (p)->hq[6])<<8)| \
+    (CAST(uint64_t, (p)->hq[7])))
+#define LE64(p) ( \
+    (CAST(uint64_t, (p)->hq[7])<<56)| \
+    (CAST(uint64_t, (p)->hq[6])<<48)| \
+    (CAST(uint64_t, (p)->hq[5])<<40)| \
+    (CAST(uint64_t, (p)->hq[4])<<32)| \
+    (CAST(uint64_t, (p)->hq[3])<<24)| \
+    (CAST(uint64_t, (p)->hq[2])<<16)| \
+    (CAST(uint64_t, (p)->hq[1])<<8)| \
+    (CAST(uint64_t, (p)->hq[0])))
+#define LE32(p) ( \
+    (CAST(uint32_t, (p)->hl[3])<<24)| \
+    (CAST(uint32_t, (p)->hl[2])<<16)| \
+    (CAST(uint32_t, (p)->hl[1])<<8)| \
+    (CAST(uint32_t, (p)->hl[0])))
+#define BE32(p) ( \
+    (CAST(uint32_t, (p)->hl[0])<<24)| \
+    (CAST(uint32_t, (p)->hl[1])<<16)| \
+    (CAST(uint32_t, (p)->hl[2])<<8)| \
+    (CAST(uint32_t, (p)->hl[3])))
+#define ME32(p) ( \
+    (CAST(uint32_t, (p)->hl[1])<<24)| \
+    (CAST(uint32_t, (p)->hl[0])<<16)| \
+    (CAST(uint32_t, (p)->hl[3])<<8)| \
+    (CAST(uint32_t, (p)->hl[2])))
+
+#define BE16(p) ((CAST(uint16_t, (p)->hs[0])<<8)|(CAST(uint16_t, (p)->hs[1])))
+#define LE16(p) ((CAST(uint16_t, (p)->hs[1])<<8)|(CAST(uint16_t, (p)->hs[0])))
+#define SEXT(s,v,p) ((s) ? \
+	CAST(intmax_t, CAST(int##v##_t, p)) : \
+	CAST(intmax_t, CAST(uint##v##_t, p)))
 
 /*
  * softmagic - lookup one file in parsed, in-memory copy of database
@@ -478,7 +500,7 @@
 	size_t l;
 
 	for (sptr = str; (ptr = strstr(sptr, "${")) != NULL;) {
-		l = (size_t)(ptr - sptr);
+		l = CAST(size_t, ptr - sptr);
 		if (l >= len)
 			return -1;
 		memcpy(buf, sptr, l);
@@ -544,19 +566,19 @@
 
   	switch (m->type) {
   	case FILE_BYTE:
-		v = file_signextend(ms, m, (uint64_t)p->b);
+		v = file_signextend(ms, m, CAST(uint64_t, p->b));
 		switch (check_fmt(ms, desc)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), "%d",
-			    (unsigned char)v);
+			    CAST(unsigned char, v));
 			if (file_printf(ms, F(ms, desc, "%s"), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, desc, "%d"),
-			    (unsigned char) v) == -1)
+			    CAST(unsigned char, v)) == -1)
 				return -1;
 			break;
 		}
@@ -566,19 +588,19 @@
   	case FILE_SHORT:
   	case FILE_BESHORT:
   	case FILE_LESHORT:
-		v = file_signextend(ms, m, (uint64_t)p->h);
+		v = file_signextend(ms, m, CAST(uint64_t, p->h));
 		switch (check_fmt(ms, desc)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), "%u",
-			    (unsigned short)v);
+			    CAST(unsigned short, v));
 			if (file_printf(ms, F(ms, desc, "%s"), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, desc, "%u"),
-			    (unsigned short) v) == -1)
+			    CAST(unsigned short, v)) == -1)
 				return -1;
 			break;
 		}
@@ -589,17 +611,19 @@
   	case FILE_BELONG:
   	case FILE_LELONG:
   	case FILE_MELONG:
-		v = file_signextend(ms, m, (uint64_t)p->l);
+		v = file_signextend(ms, m, CAST(uint64_t, p->l));
 		switch (check_fmt(ms, desc)) {
 		case -1:
 			return -1;
 		case 1:
-			(void)snprintf(buf, sizeof(buf), "%u", (uint32_t) v);
+			(void)snprintf(buf, sizeof(buf), "%u",
+			    CAST(uint32_t, v));
 			if (file_printf(ms, F(ms, desc, "%s"), buf) == -1)
 				return -1;
 			break;
 		default:
-			if (file_printf(ms, F(ms, desc, "%u"), (uint32_t) v) == -1)
+			if (file_printf(ms, F(ms, desc, "%u"),
+			    CAST(uint32_t, v)) == -1)
 				return -1;
 			break;
 		}
@@ -615,13 +639,13 @@
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), "%" INT64_T_FORMAT "u",
-			    (unsigned long long)v);
+			    CAST(unsigned long long, v));
 			if (file_printf(ms, F(ms, desc, "%s"), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, desc, "%" INT64_T_FORMAT "u"),
-			    (unsigned long long) v) == -1)
+			    CAST(unsigned long long, v)) == -1)
 				return -1;
 			break;
 		}
@@ -650,13 +674,13 @@
 
 			if (m->str_flags & STRING_TRIM) {
 				char *last;
-				while (isspace((unsigned char)*str))
+				while (isspace(CAST(unsigned char, *str)))
 					str++;
 				last = str;
 				while (*last)
 					last++;
 				--last;
-				while (isspace((unsigned char)*last))
+				while (isspace(CAST(unsigned char, *last)))
 					last--;
 				*++last = '\0';
 			}
@@ -763,7 +787,8 @@
 		char *cp;
 		int rval;
 
-		cp = strndup((const char *)ms->search.s, ms->search.rm_len);
+		cp = strndup(RCAST(const char *, ms->search.s),
+		    ms->search.rm_len);
 		if (cp == NULL) {
 			file_oomem(ms, ms->search.rm_len);
 			return -1;
@@ -805,7 +830,7 @@
 		file_magerror(ms, "invalid m->type (%d) in mprint()", m->type);
 		return -1;
 	}
-	return (int32_t)t;
+	return CAST(int32_t, t);
 }
 
 private int
@@ -852,7 +877,8 @@
 				p->s[strcspn(p->s, "\r\n")] = '\0';
 			o = CAST(uint32_t, (ms->offset + strlen(p->s)));
 			if (m->type == FILE_PSTRING)
-				o += (uint32_t)file_pstring_length_size(m);
+				o += CAST(uint32_t,
+				    file_pstring_length_size(m));
 		}
 		break;
 
@@ -918,7 +944,7 @@
 	case FILE_DER:
 		{
 			o = der_offs(ms, m, nbytes);
-			if (o == -1 || (size_t)o > nbytes) {
+			if (o == -1 || CAST(size_t, o) > nbytes) {
 				if ((ms->flags & MAGIC_DEBUG) != 0) {
 					(void)fprintf(stderr,
 					    "Bad DER offset %d nbytes=%"
@@ -935,7 +961,7 @@
 		break;
 	}
 
-	if ((size_t)o > nbytes) {
+	if (CAST(size_t, o) > nbytes) {
 #if 0
 		file_error(ms, 0, "Offset out of range %" SIZE_T_FORMAT
 		    "u > %" SIZE_T_FORMAT "u", (size_t)o, nbytes);
@@ -1008,36 +1034,36 @@
 		return type;
 	}
 }
-#define DO_CVT(fld, cast) \
+#define DO_CVT(fld, type) \
 	if (m->num_mask) \
 		switch (m->mask_op & FILE_OPS_MASK) { \
 		case FILE_OPAND: \
-			p->fld &= cast m->num_mask; \
+			p->fld &= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPOR: \
-			p->fld |= cast m->num_mask; \
+			p->fld |= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPXOR: \
-			p->fld ^= cast m->num_mask; \
+			p->fld ^= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPADD: \
-			p->fld += cast m->num_mask; \
+			p->fld += CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPMINUS: \
-			p->fld -= cast m->num_mask; \
+			p->fld -= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPMULTIPLY: \
-			p->fld *= cast m->num_mask; \
+			p->fld *= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPDIVIDE: \
-			if (cast m->num_mask == 0) \
+			if (CAST(type, m->num_mask) == 0) \
 				return -1; \
-			p->fld /= cast m->num_mask; \
+			p->fld /= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPMODULO: \
-			if (cast m->num_mask == 0) \
+			if (CAST(type, m->num_mask) == 0) \
 				return -1; \
-			p->fld %= cast m->num_mask; \
+			p->fld %= CAST(type, m->num_mask); \
 			break; \
 		} \
 	if (m->mask_op & FILE_OPINVERSE) \
@@ -1046,61 +1072,61 @@
 private int
 cvt_8(union VALUETYPE *p, const struct magic *m)
 {
-	DO_CVT(b, (uint8_t));
+	DO_CVT(b, uint8_t);
 	return 0;
 }
 
 private int
 cvt_16(union VALUETYPE *p, const struct magic *m)
 {
-	DO_CVT(h, (uint16_t));
+	DO_CVT(h, uint16_t);
 	return 0;
 }
 
 private int
 cvt_32(union VALUETYPE *p, const struct magic *m)
 {
-	DO_CVT(l, (uint32_t));
+	DO_CVT(l, uint32_t);
 	return 0;
 }
 
 private int
 cvt_64(union VALUETYPE *p, const struct magic *m)
 {
-	DO_CVT(q, (uint64_t));
+	DO_CVT(q, uint64_t);
 	return 0;
 }
 
-#define DO_CVT2(fld, cast) \
+#define DO_CVT2(fld, type) \
 	if (m->num_mask) \
 		switch (m->mask_op & FILE_OPS_MASK) { \
 		case FILE_OPADD: \
-			p->fld += cast m->num_mask; \
+			p->fld += CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPMINUS: \
-			p->fld -= cast m->num_mask; \
+			p->fld -= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPMULTIPLY: \
-			p->fld *= cast m->num_mask; \
+			p->fld *= CAST(type, m->num_mask); \
 			break; \
 		case FILE_OPDIVIDE: \
-			if (cast m->num_mask == 0) \
+			if (CAST(type, m->num_mask) == 0) \
 				return -1; \
-			p->fld /= cast m->num_mask; \
+			p->fld /= CAST(type, m->num_mask); \
 			break; \
 		} \
 
 private int
 cvt_float(union VALUETYPE *p, const struct magic *m)
 {
-	DO_CVT2(f, (float));
+	DO_CVT2(f, float);
 	return 0;
 }
 
 private int
 cvt_double(union VALUETYPE *p, const struct magic *m)
 {
-	DO_CVT2(d, (double));
+	DO_CVT2(d, double);
 	return 0;
 }
 
@@ -1165,14 +1191,14 @@
 		return 1;
 	}
 	case FILE_BESHORT:
-		p->h = (short)BE16(p);
+		p->h = CAST(short, BE16(p));
 		if (cvt_16(p, m) == -1)
 			goto out;
 		return 1;
 	case FILE_BELONG:
 	case FILE_BEDATE:
 	case FILE_BELDATE:
-		p->l = (int32_t)BE32(p);
+		p->l = CAST(int32_t, BE32(p));
 		if (cvt_32(p, m) == -1)
 			goto out;
 		return 1;
@@ -1180,19 +1206,19 @@
 	case FILE_BEQDATE:
 	case FILE_BEQLDATE:
 	case FILE_BEQWDATE:
-		p->q = (uint64_t)BE64(p);
+		p->q = CAST(uint64_t, BE64(p));
 		if (cvt_64(p, m) == -1)
 			goto out;
 		return 1;
 	case FILE_LESHORT:
-		p->h = (short)LE16(p);
+		p->h = CAST(short, LE16(p));
 		if (cvt_16(p, m) == -1)
 			goto out;
 		return 1;
 	case FILE_LELONG:
 	case FILE_LEDATE:
 	case FILE_LELDATE:
-		p->l = (int32_t)LE32(p);
+		p->l = CAST(int32_t, LE32(p));
 		if (cvt_32(p, m) == -1)
 			goto out;
 		return 1;
@@ -1200,14 +1226,14 @@
 	case FILE_LEQDATE:
 	case FILE_LEQLDATE:
 	case FILE_LEQWDATE:
-		p->q = (uint64_t)LE64(p);
+		p->q = CAST(uint64_t, LE64(p));
 		if (cvt_64(p, m) == -1)
 			goto out;
 		return 1;
 	case FILE_MELONG:
 	case FILE_MEDATE:
 	case FILE_MELDATE:
-		p->l = (int32_t)ME32(p);
+		p->l = CAST(int32_t, ME32(p));
 		if (cvt_32(p, m) == -1)
 			goto out;
 		return 1;
@@ -1388,7 +1414,7 @@
 	 * might even cause problems
 	 */
 	if (nbytes < sizeof(*p))
-		(void)memset(((char *)(void *)p) + nbytes, '\0',
+		(void)memset(RCAST(char *, RCAST(void *, p)) + nbytes, '\0',
 		    sizeof(*p) - nbytes);
 	return 0;
 }
@@ -1429,7 +1455,7 @@
 	if (m->in_op & FILE_OPINVERSE)
 		offset = ~offset;
 
-	return (uint32_t)offset;
+	return CAST(uint32_t, offset);
 }
 
 private int
@@ -1454,10 +1480,10 @@
 			    "u at level %u", o, cont_level);
 			return -1;
 		}
-		if ((size_t)-m->offset > b->elen)
+		if (CAST(size_t, -m->offset) > b->elen)
 			return -1;
 		buffer_init(bb, -1, b->ebuf, b->elen);
-		ms->eoffset = ms->offset = (int32_t)(b->elen + m->offset);
+		ms->eoffset = ms->offset = CAST(int32_t, b->elen + m->offset);
 	} else {
 		if (cont_level == 0) {
 normal:
@@ -1508,8 +1534,8 @@
 
 
 
-	if (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),
-	    (uint32_t)nbytes, m) == -1)
+	if (mcopy(ms, p, m->type, m->flag & INDIR, s,
+	    CAST(uint32_t, offset + o), CAST(uint32_t, nbytes), m) == -1)
 		return -1;
 
 	if ((ms->flags & MAGIC_DEBUG) != 0) {
@@ -1518,7 +1544,8 @@
 		    "u, il=%hu, nc=%hu)\n",
 		    m->type, m->flag, offset, o, nbytes,
 		    *indir_count, *name_count);
-		mdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));
+		mdebug(offset, RCAST(char *, RCAST(void *, p)),
+		    sizeof(union VALUETYPE));
 #ifndef COMPILE_ONLY
 		file_mdump(m);
 #endif
@@ -1529,7 +1556,7 @@
 		const int sgn = m->in_op & FILE_OPSIGNED;
 		if (m->in_op & FILE_OPINDIRECT) {
 			const union VALUETYPE *q = CAST(const union VALUETYPE *,
-			    ((const void *)(s + offset + off)));
+			    RCAST(const void *, s + offset + off));
 			switch (cvt_flip(m->in_type, flip)) {
 			case FILE_BYTE:
 				if (OFFSET_OOB(nbytes, offset + off, 1))
@@ -1616,7 +1643,7 @@
 				return 0;
 			lhs = BE32(p);
 			if (in_type == FILE_BEID3)
-				lhs = cvt_id3(ms, (uint32_t)lhs);
+				lhs = cvt_id3(ms, CAST(uint32_t, lhs));
 			offset = do_ops(m, SEXT(sgn,32,lhs), off);
 			break;
 		case FILE_LELONG:
@@ -1625,7 +1652,7 @@
 				return 0;
 			lhs = LE32(p);
 			if (in_type == FILE_LEID3)
-				lhs = cvt_id3(ms, (uint32_t)lhs);
+				lhs = cvt_id3(ms, CAST(uint32_t, lhs));
 			offset = do_ops(m, SEXT(sgn,32,lhs), off);
 			break;
 		case FILE_MELONG:
@@ -1668,7 +1695,7 @@
 		ms->offset = offset;
 
 		if ((ms->flags & MAGIC_DEBUG) != 0) {
-			mdebug(offset, (char *)(void *)p,
+			mdebug(offset, RCAST(char *, RCAST(void *, p)),
 			    sizeof(union VALUETYPE));
 #ifndef COMPILE_ONLY
 			file_mdump(m);
@@ -1819,8 +1846,8 @@
 	 * the ctype functions will work correctly without extra
 	 * casting.
 	 */
-	const unsigned char *a = (const unsigned char *)s1;
-	const unsigned char *b = (const unsigned char *)s2;
+	const unsigned char *a = RCAST(const unsigned char *, s1);
+	const unsigned char *b = RCAST(const unsigned char *, s2);
 	const unsigned char *eb = b + len;
 	uint64_t v;
 
@@ -2015,13 +2042,15 @@
 	case FILE_STRING:
 	case FILE_PSTRING:
 		l = 0;
-		v = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);
+		v = file_strncmp(m->value.s, p->s, CAST(size_t, m->vallen),
+		    m->str_flags);
 		break;
 
 	case FILE_BESTRING16:
 	case FILE_LESTRING16:
 		l = 0;
-		v = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);
+		v = file_strncmp16(m->value.s, p->s, CAST(size_t, m->vallen),
+		    m->str_flags);
 		break;
 
 	case FILE_SEARCH: { /* search ms->search.s for the string m->value.s */
@@ -2063,7 +2092,7 @@
 		    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));
 		if (rc) {
 			file_regerror(&rx, rc, ms);
-			v = (uint64_t)-1;
+			v = CAST(uint64_t, -1);
 		} else {
 			regmatch_t pmatch;
 			size_t slen = ms->search.s_len;
@@ -2084,15 +2113,15 @@
 			    search = CCAST(char *, "");
 			    copy = NULL;
 			}
-			rc = file_regexec(&rx, (const char *)search,
+			rc = file_regexec(&rx, RCAST(const char *, search),
 			    1, &pmatch, 0);
 			free(copy);
 			switch (rc) {
 			case 0:
-				ms->search.s += (int)pmatch.rm_so;
-				ms->search.offset += (size_t)pmatch.rm_so;
-				ms->search.rm_len =
-				    (size_t)(pmatch.rm_eo - pmatch.rm_so);
+				ms->search.s += CAST(int, pmatch.rm_so);
+				ms->search.offset += CAST(size_t, pmatch.rm_so);
+				ms->search.rm_len = CAST(size_t, 
+				    pmatch.rm_eo - pmatch.rm_so);
 				v = 0;
 				break;
 
@@ -2102,12 +2131,12 @@
 
 			default:
 				file_regerror(&rx, rc, ms);
-				v = (uint64_t)-1;
+				v = CAST(uint64_t, -1);
 				break;
 			}
 		}
 		file_regfree(&rx);
-		if (v == (uint64_t)-1)
+		if (v == CAST(uint64_t, -1))
 			return -1;
 		break;
 	}
@@ -2136,7 +2165,7 @@
 	case 'x':
 		if ((ms->flags & MAGIC_DEBUG) != 0)
 			(void) fprintf(stderr, "%" INT64_T_FORMAT
-			    "u == *any* = 1\n", (unsigned long long)v);
+			    "u == *any* = 1\n", CAST(unsigned long long, v));
 		matched = 1;
 		break;
 
@@ -2144,16 +2173,18 @@
 		matched = v != l;
 		if ((ms->flags & MAGIC_DEBUG) != 0)
 			(void) fprintf(stderr, "%" INT64_T_FORMAT "u != %"
-			    INT64_T_FORMAT "u = %d\n", (unsigned long long)v,
-			    (unsigned long long)l, matched);
+			    INT64_T_FORMAT "u = %d\n",
+			    CAST(unsigned long long, v),
+			    CAST(unsigned long long, l), matched);
 		break;
 
 	case '=':
 		matched = v == l;
 		if ((ms->flags & MAGIC_DEBUG) != 0)
 			(void) fprintf(stderr, "%" INT64_T_FORMAT "u == %"
-			    INT64_T_FORMAT "u = %d\n", (unsigned long long)v,
-			    (unsigned long long)l, matched);
+			    INT64_T_FORMAT "u = %d\n",
+			    CAST(unsigned long long, v),
+			    CAST(unsigned long long, l), matched);
 		break;
 
 	case '>':
@@ -2162,15 +2193,16 @@
 			if ((ms->flags & MAGIC_DEBUG) != 0)
 				(void) fprintf(stderr, "%" INT64_T_FORMAT
 				    "u > %" INT64_T_FORMAT "u = %d\n",
-				    (unsigned long long)v,
-				    (unsigned long long)l, matched);
+				    CAST(unsigned long long, v),
+				    CAST(unsigned long long, l), matched);
 		}
 		else {
-			matched = (int64_t) v > (int64_t) l;
+			matched = CAST(int64_t, v) > CAST(int64_t, l);
 			if ((ms->flags & MAGIC_DEBUG) != 0)
 				(void) fprintf(stderr, "%" INT64_T_FORMAT
 				    "d > %" INT64_T_FORMAT "d = %d\n",
-				    (long long)v, (long long)l, matched);
+				    CAST(long long, v),
+				    CAST(long long, l), matched);
 		}
 		break;
 
@@ -2180,15 +2212,16 @@
 			if ((ms->flags & MAGIC_DEBUG) != 0)
 				(void) fprintf(stderr, "%" INT64_T_FORMAT
 				    "u < %" INT64_T_FORMAT "u = %d\n",
-				    (unsigned long long)v,
-				    (unsigned long long)l, matched);
+				    CAST(unsigned long long, v),
+				    CAST(unsigned long long, l), matched);
 		}
 		else {
-			matched = (int64_t) v < (int64_t) l;
+			matched = CAST(int64_t, v) < CAST(int64_t, l);
 			if ((ms->flags & MAGIC_DEBUG) != 0)
 				(void) fprintf(stderr, "%" INT64_T_FORMAT
 				    "d < %" INT64_T_FORMAT "d = %d\n",
-				     (long long)v, (long long)l, matched);
+				     CAST(long long, v),
+				     CAST(long long, l), matched);
 		}
 		break;
 
@@ -2197,8 +2230,9 @@
 		if ((ms->flags & MAGIC_DEBUG) != 0)
 			(void) fprintf(stderr, "((%" INT64_T_FORMAT "x & %"
 			    INT64_T_FORMAT "x) == %" INT64_T_FORMAT
-			    "x) = %d\n", (unsigned long long)v,
-			    (unsigned long long)l, (unsigned long long)l,
+			    "x) = %d\n", CAST(unsigned long long, v),
+			    CAST(unsigned long long, l),
+			    CAST(unsigned long long, l),
 			    matched);
 		break;
 
@@ -2207,9 +2241,9 @@
 		if ((ms->flags & MAGIC_DEBUG) != 0)
 			(void) fprintf(stderr, "((%" INT64_T_FORMAT "x & %"
 			    INT64_T_FORMAT "x) != %" INT64_T_FORMAT
-			    "x) = %d\n", (unsigned long long)v,
-			    (unsigned long long)l, (unsigned long long)l,
-			    matched);
+			    "x) = %d\n", CAST(unsigned long long, v),
+			    CAST(unsigned long long, l),
+			    CAST(unsigned long long, l), matched);
 		break;
 
 	default:
