Subject: Handle negative numbers in overflow calculation
Origin: FILE5_43-55-gbd3cac67 <https://github.com/file/file/commit/FILE5_43-55-gbd3cac67>
Upstream-Author: Christos Zoulas <christos@zoulas.com>
Date: Sun Oct 2 15:21:27 2022 +0000

--- a/src/apprentice.c
+++ b/src/apprentice.c
@@ -2832,6 +2832,7 @@
 {
 	char *ep;
 	uint64_t ull;
+	int y;
 
 	switch (m->type) {
 	case FILE_BESTRING16:
@@ -2916,21 +2917,25 @@
 			switch (ts) {
 			case 1:
 				x = CAST(uint64_t, ull & ~0xffULL);
+				y = (x & ~0xffULL) != ~0xffULL;
 				break;
 			case 2:
 				x = CAST(uint64_t, ull & ~0xffffULL);
+				y = (x & ~0xffffULL) != ~0xffffULL;
 				break;
 			case 4:
 				x = CAST(uint64_t, ull & ~0xffffffffULL);
+				y = (x & ~0xffffffffULL) != ~0xffffffffULL;
 				break;
 			case 8:
 				x = 0;
+				y = 0;
 				break;
 			default:
 				fprintf(stderr, "Bad width %zu", ts);
 				abort();
 			}
-			if (x) {
+			if (x && y) {
 				file_magwarn(ms, "Overflow for numeric"
 				    " type `%s' value %#" PRIx64,
 				    type_tbl[m->type].name, ull);
